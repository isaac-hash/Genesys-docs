[
  {
    "slug": "/basic-setup/changelog",
    "title": "Changelog",
    "description": "Changelogs and improvements to the Documents projects.",
    "content": "## Added\n\n**Linting and Formatting**:\n\n* Added `pnpm run lint` and `pnpm run lint:fix` scripts to automate linting tasks.\n* Added `pnpm run format` and `pnpm run format:check` scripts to ensure consistent code formatting.\n\n**SEO Enhancements**:\n\n* Added an SEO component to MDX pages to dynamically include `keywords` and `lastModified` metadata for improved SEO generation.\n\n## Updated\n\n**Next.js Upgrade**:\n\n* Upgraded the project from **Next.js 14** to **Next.js 15**, leveraging the latest features and performance improvements.\n\n**Codebase Improvements**:\n\n* Reordered imports across the project files for better consistency and readability.\n\n**Mermaid Component**:\n\n* Fixed an ID bug that caused rendering issues when multiple Mermaid diagrams were included in MDX pages.\n* Improved initialization and rendering logic to prevent duplicate diagram rendering.\n",
    "_searchMeta": {
      "cleanContent": "added linting and formatting: added pnpm run lint and pnpm run lint:fix scripts to automate linting tasks added pnpm run format and pnpm run format:check scripts to ensure consistent code formatting seo enhancements: added an seo component to mdx pages to dynamically include keywords and lastmodified metadata for improved seo generation updated next js upgrade: upgraded the project from next js 14 to next js 15 leveraging the latest features and performance improvements codebase improvements: reordered imports across the project files for better consistency and readability mermaid component: fixed an id bug that caused rendering issues when multiple mermaid diagrams were included in mdx pages improved initialization and rendering logic to prevent duplicate diagram rendering",
      "headings": [
        "Added",
        "Updated"
      ],
      "keywords": [
        "changelog",
        "guide",
        "nextjs",
        "documents",
        "Added",
        "Updated",
        "Linting and Formatting",
        "SEO Enhancements",
        "Next.js Upgrade",
        "Next.js 14",
        "Next.js 15",
        "Codebase Improvements",
        "Mermaid Component",
        "pnpm run lint",
        "pnpm run lint:fix",
        "pnpm run format",
        "pnpm run format:check",
        "keywords",
        "lastModified"
      ]
    }
  },
  {
    "slug": "/basic-setup",
    "title": "Introduction",
    "description": "This section provides an overview of how to get started with the Documents, Next.js Document Starter Kit.",
    "content": "![Banner](/images/genesys-banner-gif.gif \"Documents\")\n\n## Documents\n\n**Documents** is a lightweight, modular starter kit built with **Next.js**, **React**, **Tailwind CSS**, and **TypeScript**. It‚Äôs designed to help you\r\nlaunch structured, professional documentation without spending time on boilerplate.\n\nWhether you're building product manuals, internal systems guides, or dev documentation, Documents gives you a clean foundation that‚Äôs easy to\r\nextend and maintain.\n\n## Why use Documents?\n\nThis kit was built to simplify how teams manage and publish documentation. It works across projects of all sizes‚Äîfrom a single\r\nreadme to enterprise knowledge bases.\n\nWith MDX, reusable components, and Tailwind styling, it keeps your workflow efficient without compromising flexibility.\n\nUse it for:\n\n* **Product Guides** ‚Äì Setup, usage, and troubleshooting\n* **Internal Docs** ‚Äì Processes, policies, and team references\n* **Technical Manuals** ‚Äì APIs, SDKs, architecture walkthroughs\n\nCustomize the UI and structure to match your brand or workflow‚Äîno lock-in.\n\n## Core Features\n\n| Feature                              | Description                                                                 |\r\n| ------------------------------------ | --------------------------------------------------------------------------- |\r\n| **Write in Markdown/MDX**            | Combine Markdown with components and Mermaid.js for rich content.           |\r\n| **Flexible Navigation**              | Multi-level menus, page hierarchy, and auto-generated TOCs.                 |\r\n| **Code Support**                     | Syntax highlighting, code tabs, and one-click copy.                         |\r\n| **Search**                           | Fuzzy matching with highlight and instant results.                          |\r\n| **Responsive Design**                | Built-in light/dark mode with mobile support.                               |\r\n| **Math + Tables**                    | LaTeX rendering and clean table styling.                                    |\r\n| **SEO Defaults**                     | Preconfigured meta, Open Graph, and structured data.                        |\r\n| **AI Docs (Upcoming)**               | AI tools for smart search and content generation (coming soon).             |\n\n## Using This Kit\n\nNavigation is on the left. Pages flow from setup to advanced features, but you're free to jump around.\n\nUse the table of contents on the right to skip through sections.\n\nStart with the [Installation Guide](/docs/basic-setup/installation).\n\n## Community Support\n\nGot questions? Reach out via:\n\n* [GitHub](https://github.com/rubixvi/rubix-documents)\n* [Twitter](https://x.com/rubixstory)\n* [Facebook](https://www.facebook.com/rubixstudios)\n",
    "_searchMeta": {
      "cleanContent": "banner documents documents is a lightweight modular starter kit built with next js react tailwind css and typescript it s designed to help you launch structured professional documentation without spending time on boilerplate whether you re building product manuals internal systems guides or dev documentation documents gives you a clean foundation that s easy to extend and maintain why use documents this kit was built to simplify how teams manage and publish documentation it works across projects of all sizes from a single readme to enterprise knowledge bases with mdx reusable components and tailwind styling it keeps your workflow efficient without compromising flexibility use it for: product guides setup usage and troubleshooting internal docs processes policies and team references technical manuals apis sdks architecture walkthroughs customize the ui and structure to match your brand or workflow no lock-in core features feature description ------------------------------------ --------------------------------------------------------------------------- write in markdown mdx combine markdown with components and mermaid js for rich content flexible navigation multi-level menus page hierarchy and auto-generated tocs code support syntax highlighting code tabs and one-click copy search fuzzy matching with highlight and instant results responsive design built-in light dark mode with mobile support math tables latex rendering and clean table styling seo defaults preconfigured meta open graph and structured data ai docs upcoming ai tools for smart search and content generation coming soon using this kit navigation is on the left pages flow from setup to advanced features but you re free to jump around use the table of contents on the right to skip through sections start with the installation guide community support got questions reach out via: github twitter facebook",
      "headings": [
        "Documents",
        "Why use Documents?",
        "Core Features",
        "Using This Kit",
        "Community Support"
      ],
      "keywords": [
        "introduction",
        "guide",
        "nextjs",
        "documents",
        "Documents",
        "Why use Documents?",
        "Core Features",
        "Using This Kit",
        "Community Support",
        "Next.js",
        "React",
        "Tailwind CSS",
        "TypeScript",
        "Product Guides",
        "Internal Docs",
        "Technical Manuals",
        "Write in Markdown/MDX",
        "Flexible Navigation",
        "Code Support",
        "Search",
        "Responsive Design",
        "Math + Tables",
        "SEO Defaults",
        "AI Docs (Upcoming)"
      ]
    }
  },
  {
    "slug": "/basic-setup/installation",
    "title": "Installation",
    "description": "Learn how to install ROS 2 and set up the Genesys Robotics Framework on your system.",
    "content": "This guide walks you through installing **ROS 2** and setting up the **Genesys Robotics Framework** on your system.\\\nFollow each step carefully to ensure a smooth setup experience.\n\n## Prerequisites\n\n***\n\n## Installing ROS 2\n\n***\n\n## Installing Genesys Framework\n\n***\n\n## Project Structure\n\nThe Genesys framework installs the following structure:\n\n```\ngenesys/\r\n ‚îú‚îÄ‚îÄ src/                 # ROS 2 packages (C++ & Python)\r\n ‚îú‚îÄ‚îÄ config/              # YAML configuration files\r\n ‚îú‚îÄ‚îÄ launch/              # ROS 2 launch files\r\n ‚îú‚îÄ‚îÄ worlds/              # Simulation files for Gazebo\r\n ‚îú‚îÄ‚îÄ scripts/             # Utility scripts\r\n ‚îú‚îÄ‚îÄ docs/                # Documentation\r\n ‚îî‚îÄ‚îÄ install/             # Built workspace\n```\n\n***\n\n## Running Genesys\n\n***\n\n## Optional Tools\n\n***\n\n## Important Notes\n\n* Always build after modifying packages:\n\n  ```bash\n  colcon build\n  ```\n* Always source your workspace:\n\n  ```bash\n  source install/setup.bash\n  ```\n* Genesys requires ROS 2 Humble or newer.\n\n***\n",
    "_searchMeta": {
      "cleanContent": "this guide walks you through installing ros 2 and setting up the genesys robotics framework on your system follow each step carefully to ensure a smooth setup experience prerequisites installing ros 2 installing genesys framework project structure the genesys framework installs the following structure: running genesys optional tools important notes always build after modifying packages: always source your workspace: genesys requires ros 2 humble or newer",
      "headings": [
        "Prerequisites",
        "Installing ROS 2",
        "Installing Genesys Framework",
        "Project Structure",
        "Running Genesys",
        "Optional Tools",
        "Important Notes"
      ],
      "keywords": [
        "ros2",
        "installation",
        "genesys",
        "robotics framework",
        "ubuntu",
        "setup",
        "Prerequisites",
        "Installing ROS 2",
        "Installing Genesys Framework",
        "Project Structure",
        "Running Genesys",
        "Optional Tools",
        "Important Notes",
        "ROS 2",
        "Genesys Robotics Framework",
        "## Installing ROS 2",
        "## Project Structure\n\nThe Genesys framework installs the following structure:\n\n```\ngenesys/\r\n ‚îú‚îÄ‚îÄ src/                 # ROS 2 packages (C++ & Python)\r\n ‚îú‚îÄ‚îÄ config/              # YAML configuration files\r\n ‚îú‚îÄ‚îÄ launch/              # ROS 2 launch files\r\n ‚îú‚îÄ‚îÄ worlds/              # Simulation files for Gazebo\r\n ‚îú‚îÄ‚îÄ scripts/             # Utility scripts\r\n ‚îú‚îÄ‚îÄ docs/                # Documentation\r\n ‚îî‚îÄ‚îÄ install/             # Built workspace\n```",
        "## Optional Tools",
        "genesys/\r\n ‚îú‚îÄ‚îÄ src/                 # ROS 2 packages (C++ & Python)\r\n ‚îú‚îÄ‚îÄ config/              # YAML configuration files\r\n ‚îú‚îÄ‚îÄ launch/              # ROS 2 launch files\r\n ‚îú‚îÄ‚îÄ worlds/              # Simulation files for Gazebo\r\n ‚îú‚îÄ‚îÄ scripts/             # Utility scripts\r\n ‚îú‚îÄ‚îÄ docs/                # Documentation\r\n ‚îî‚îÄ‚îÄ install/             # Built workspace",
        "***\n\n## Running Genesys\n\n***\n\n## Optional Tools\n\n***\n\n## Important Notes\n\n* Always build after modifying packages:",
        "bash\n  colcon build",
        "* Always source your workspace:",
        "bash\n  source install/setup.bash"
      ]
    }
  },
  {
    "slug": "/basic-setup/introduction",
    "title": "Welcome",
    "description": "Introduction to the Genesys Framework ‚Äî an opinionated, developer-friendly layer on top of ROS 2.",
    "content": "# Welcome to the Genesys Framework Documentation\n\nWelcome to the official documentation for **Genesys**, an opinionated, developer-friendly framework for **ROS 2**.\\\nGenesys is built to reduce boilerplate, streamline common workflows, and give you a clear ‚Äúhappy path‚Äù for robotics development.\n\nIt wraps the powerful ‚Äî but often verbose ‚Äî ROS 2 toolchain into a unified, intuitive CLI so you can focus on *robot logic*, not endless setup.\n\nThe goal of Genesys is **not** to replace ROS 2, but to enhance it. It provides a powerful foundation so you can focus on creating innovative features and delivering value.\n\n:::note\r\n**Key Principle:** Every Genesys project remains a **100% valid ROS 2 project**.\\\nYou can always fall back to native tools like `colcon build` and `ros2 run` at any time.\r\n:::\n\n***\n\n## Why Genesys?\n\nGenesys was created to solve common pain points for both new and experienced ROS 2 developers:\n\n### üîß Simplified Build System\n\nAutomates package creation, dependency management, and the entire `colcon build` process into a single:\n\n```bash\ngenesys build\n```\n\n## ‚ú® Zero Boilerplate\n\nGenesys simplifies robotics development by eliminating repetitive ROS 2 boilerplate.\n\nIt uses Python decorators such as:\n\n* `@node`\n* `@publisher`\n* `@subscriber`\n* `@timer`\n\n‚Ä¶and C++ macros to drastically simplify node and topic creation.\n\n***\n\n## ‚öôÔ∏è Automated Configuration\n\nGenesys automatically generates and registers:\n\n* Launch files\n* Configuration files\n* Executables\n\nNo more manually editing:\n\n* `setup.py`\n* `CMakeLists.txt`\n\nJust to add or modify a node.\n\n***\n\n## üß∞ Unified Tooling\n\nGenesys provides a single, cohesive CLI:\n\n```bash\ngenesys\n```\n\n* Creating new packages\n* Building workspaces\n* Running nodes\n* Launching simulations\n* Managing config files\n* Organizing your entire robotics workflow\n\n## Jump Right In\n\nLearn how each decorator simplifies ROS 2 development.\n\n## Join the Community\n\nGenesys is an open, collaborative project ‚Äî and we welcome contributions!\n\nWhether you're:\n\n* Reporting a bug\n* Suggesting a feature\n* Improving the docs\n* Submitting code\n\nYour contributions help shape the future of the framework.\n\n### GitHub Repository\n\nüëâ [https://github.com/isaac-hash/Genesys](https://github.com/isaac-hash/Genesys)\n\nView the source, submit PRs, or open issues.\n\nWe're excited to see what you build with Genesys!\n",
    "_searchMeta": {
      "cleanContent": "welcome to the genesys framework documentation welcome to the official documentation for genesys an opinionated developer-friendly framework for ros 2 genesys is built to reduce boilerplate streamline common workflows and give you a clear happy path for robotics development it wraps the powerful but often verbose ros 2 toolchain into a unified intuitive cli so you can focus on robot logic not endless setup the goal of genesys is not to replace ros 2 but to enhance it it provides a powerful foundation so you can focus on creating innovative features and delivering value :::note key principle: every genesys project remains a 100 valid ros 2 project you can always fall back to native tools like colcon build and ros2 run at any time ::: why genesys genesys was created to solve common pain points for both new and experienced ros 2 developers: simplified build system automates package creation dependency management and the entire colcon build process into a single: zero boilerplate genesys simplifies robotics development by eliminating repetitive ros 2 boilerplate it uses python decorators such as: node publisher subscriber timer and c macros to drastically simplify node and topic creation automated configuration genesys automatically generates and registers: launch files configuration files executables no more manually editing: setup py cmakelists txt just to add or modify a node unified tooling genesys provides a single cohesive cli: creating new packages building workspaces running nodes launching simulations managing config files organizing your entire robotics workflow jump right in learn how each decorator simplifies ros 2 development join the community genesys is an open collaborative project and we welcome contributions whether you re: reporting a bug suggesting a feature improving the docs submitting code your contributions help shape the future of the framework github repository https: github com isaac-hash genesys view the source submit prs or open issues we re excited to see what you build with genesys",
      "headings": [
        "Why Genesys?",
        "‚ú® Zero Boilerplate",
        "‚öôÔ∏è Automated Configuration",
        "üß∞ Unified Tooling",
        "Jump Right In",
        "Join the Community"
      ],
      "keywords": [
        "genesys",
        "ros2",
        "framework",
        "robotics",
        "quickstart",
        "Why Genesys?",
        "‚ú® Zero Boilerplate",
        "‚öôÔ∏è Automated Configuration",
        "üß∞ Unified Tooling",
        "Jump Right In",
        "Join the Community",
        "Genesys",
        "ROS 2",
        "not",
        "Key Principle:",
        "100% valid ROS 2 project",
        "colcon build",
        "ros2 run",
        "bash\ngenesys build",
        "## ‚ú® Zero Boilerplate\n\nGenesys simplifies robotics development by eliminating repetitive ROS 2 boilerplate.\n\nIt uses Python decorators such as:\n\n*",
        "*",
        "‚Ä¶and C++ macros to drastically simplify node and topic creation.\n\n***\n\n## ‚öôÔ∏è Automated Configuration\n\nGenesys automatically generates and registers:\n\n* Launch files\n* Configuration files\n* Executables\n\nNo more manually editing:\n\n*",
        "Just to add or modify a node.\n\n***\n\n## üß∞ Unified Tooling\n\nGenesys provides a single, cohesive CLI:",
        "bash\ngenesys"
      ]
    }
  },
  {
    "slug": "/basic-setup/setup",
    "title": "Setup",
    "description": "Setting up and configuring your documentation project",
    "content": "Setting up your new documentation project is straightforward. Most of the essential project settings can be configured within the `settings` folder.\n\n## Settings\n\nThis section provides the core settings for your documentation site, such as defining the site's URL, site icon and title.\n\n```tsx showLineNumbers\nexport const url = \"\"                 // The URL for your documentation site\r\nexport const siteicon = \"\"            // Icon displayed next to the site name in the header\r\nexport const sitename = \"\"            // Title of your documentation site\n```\n\n## Google Tags\n\nThis section allows you to integrate Google Tag Manager into your documentation project. You can add your GTM code and configure whether it's connected.\n\n```tsx showLineNumbers\nexport const gtm = \"\"                 // Add your Google Tag Manager code here\r\nexport const gtmconnected = true      // Set to true if GTM is connected, otherwise set to false\n```\n\n## Search Engine\n\nConfigure essential SEO settings to ensure your documentation site is optimized for search engines. This includes meta descriptions, keywords and social media sharing details like images and alt text.\n\n```tsx showLineNumbers\nexport const description = \"\"         // Description of your documentation site for SEO\r\nexport const keywords = [\"\", \"\"]      // List of SEO keywords for your documentation site\r\nexport const urlimage = \"\"            // The URL of the image used when sharing on social media)\r\nexport const imagealt = \"\"            // Alt text for shared images, helpful for screen readers\r\nexport const twitterhandle = \"\"       // Your company‚Äôs Twitter handle for social sharing\n```\n\n## Footer Branding\n\nThe footer settings allow you to customize the company information displayed at the bottom of the site. You can add the company name and the URL that the name will link to.\n\n```tsx showLineNumbers\nexport const companyname = \"\"         // The company name displayed in the copyright section\r\nexport const companylink = \"\"         // The URL your company name should link to\n```\n\n## General Layout\n\nThe layout settings control the appearance and functionality of various elements of the documentation site, such as branding, the right sidebar, feedback options, table of contents, and scroll-to-top functionality.\n\n```tsx showLineNumbers\nexport const branding = true          // Set to true to display our branding elements\r\nexport const rightsidebar = true      // Set to true to enable the right sidebar with feedback, table of contents and scroll-to-top\r\nexport const feedbackedit = true      // Control to enable/disable feedback on GitHub\r\nexport const tableofcontent = true    // Control to enable/disable the generated table of contents\r\nexport const totopscroll = true       // Control to enable/disable scroll-to-top button\n```\n\n## Github Control\n\nIf your MDX files are hosted on GitHub, you can configure the project to load documents directly from there. This option can be useful for syncing documentation updates directly with your repository.\n\n```tsx showLineNumbers\nexport const loadfromgithub = false   // Set to true to load your MDX documents directly from GitHub\n```\n\n## Project Structure\n",
    "_searchMeta": {
      "cleanContent": "setting up your new documentation project is straightforward most of the essential project settings can be configured within the settings folder settings this section provides the core settings for your documentation site such as defining the site s url site icon and title google tags this section allows you to integrate google tag manager into your documentation project you can add your gtm code and configure whether it s connected search engine configure essential seo settings to ensure your documentation site is optimized for search engines this includes meta descriptions keywords and social media sharing details like images and alt text footer branding the footer settings allow you to customize the company information displayed at the bottom of the site you can add the company name and the url that the name will link to general layout the layout settings control the appearance and functionality of various elements of the documentation site such as branding the right sidebar feedback options table of contents and scroll-to-top functionality github control if your mdx files are hosted on github you can configure the project to load documents directly from there this option can be useful for syncing documentation updates directly with your repository project structure",
      "headings": [
        "Settings",
        "Google Tags",
        "Search Engine",
        "Footer Branding",
        "General Layout",
        "Github Control",
        "Project Structure"
      ],
      "keywords": [
        "setup",
        "configuration",
        "layout",
        "Google",
        "SEO",
        "nextjs",
        "documents",
        "Settings",
        "Google Tags",
        "Search Engine",
        "Footer Branding",
        "General Layout",
        "Github Control",
        "Project Structure",
        "settings",
        "tsx showLineNumbers\nexport const url = \"\"                 // The URL for your documentation site\r\nexport const siteicon = \"\"            // Icon displayed next to the site name in the header\r\nexport const sitename = \"\"            // Title of your documentation site",
        "## Google Tags\n\nThis section allows you to integrate Google Tag Manager into your documentation project. You can add your GTM code and configure whether it's connected.",
        "tsx showLineNumbers\nexport const gtm = \"\"                 // Add your Google Tag Manager code here\r\nexport const gtmconnected = true      // Set to true if GTM is connected, otherwise set to false",
        "## Search Engine\n\nConfigure essential SEO settings to ensure your documentation site is optimized for search engines. This includes meta descriptions, keywords and social media sharing details like images and alt text.",
        "tsx showLineNumbers\nexport const description = \"\"         // Description of your documentation site for SEO\r\nexport const keywords = [\"\", \"\"]      // List of SEO keywords for your documentation site\r\nexport const urlimage = \"\"            // The URL of the image used when sharing on social media)\r\nexport const imagealt = \"\"            // Alt text for shared images, helpful for screen readers\r\nexport const twitterhandle = \"\"       // Your company‚Äôs Twitter handle for social sharing",
        "## Footer Branding\n\nThe footer settings allow you to customize the company information displayed at the bottom of the site. You can add the company name and the URL that the name will link to.",
        "tsx showLineNumbers\nexport const companyname = \"\"         // The company name displayed in the copyright section\r\nexport const companylink = \"\"         // The URL your company name should link to",
        "## General Layout\n\nThe layout settings control the appearance and functionality of various elements of the documentation site, such as branding, the right sidebar, feedback options, table of contents, and scroll-to-top functionality.",
        "tsx showLineNumbers\nexport const branding = true          // Set to true to display our branding elements\r\nexport const rightsidebar = true      // Set to true to enable the right sidebar with feedback, table of contents and scroll-to-top\r\nexport const feedbackedit = true      // Control to enable/disable feedback on GitHub\r\nexport const tableofcontent = true    // Control to enable/disable the generated table of contents\r\nexport const totopscroll = true       // Control to enable/disable scroll-to-top button",
        "## Github Control\n\nIf your MDX files are hosted on GitHub, you can configure the project to load documents directly from there. This option can be useful for syncing documentation updates directly with your repository.",
        "tsx showLineNumbers\nexport const loadfromgithub = false   // Set to true to load your MDX documents directly from GitHub"
      ]
    }
  },
  {
    "slug": "/dive-deeper/components",
    "title": "C++ Components",
    "description": "",
    "content": "# Genesys Framework Components\n\nThis document provides an overview of the components of the Genesys framework. Each feature is documented in detail in its own file.\n\n## Core Concepts\n\n* [**Decorators**](./decorators.md): Learn about the decorator-based approach for creating nodes.\n* [**Pipelines**](./pipeline.md): Understand how to define and run complex component graphs.\n\n## Command Line Interface (CLI)\n\n* [**`genesys new`**](./cli_new.md): Create a new Genesys workspace.\n* [**`genesys make`**](./cli_make.md): Scaffold packages, nodes, and components.\n* [**`genesys build`**](./cli_build.md): Build your workspace.\n* [**`genesys run`**](./cli_run.md): Run a node by its name.\n* [**`genesys launch`**](./cli_launch.md): Launch ROS 2 launch files.\n* [**`genesys pipeline`**](./cli_pipeline.md): Manage and run pipelines from the CLI.\n* [**`genesys sim`**](./cli_sim.md): Create and run Gazebo simulations.\n* [**`genesys doctor`**](./cli_doctor.md): Diagnose environment issues.\n* [**ROS 2 Wrappers**](./cli_ros.md): Use common `ros2` commands with automatic workspace sourcing.\n* [**`genesys rqt`**](./cli_rqt.md): Launch RQT tools.\n",
    "_searchMeta": {
      "cleanContent": "genesys framework components this document provides an overview of the components of the genesys framework each feature is documented in detail in its own file core concepts decorators: learn about the decorator-based approach for creating nodes pipelines: understand how to define and run complex component graphs command line interface cli genesys new: create a new genesys workspace genesys make: scaffold packages nodes and components genesys build: build your workspace genesys run: run a node by its name genesys launch: launch ros 2 launch files genesys pipeline: manage and run pipelines from the cli genesys sim: create and run gazebo simulations genesys doctor: diagnose environment issues ros 2 wrappers: use common ros2 commands with automatic workspace sourcing genesys rqt: launch rqt tools",
      "headings": [
        "Core Concepts",
        "Command Line Interface (CLI)"
      ],
      "keywords": [
        "Core Concepts",
        "Command Line Interface (CLI)",
        "Decorators",
        "Pipelines",
        "`genesys new`",
        "`genesys make`",
        "`genesys build`",
        "`genesys run`",
        "`genesys launch`",
        "`genesys pipeline`",
        "`genesys sim`",
        "`genesys doctor`",
        "ROS 2 Wrappers",
        "`genesys rqt`",
        "genesys new",
        "genesys make",
        "genesys build",
        "genesys run",
        "genesys launch",
        "genesys pipeline",
        "genesys sim",
        "genesys doctor",
        "ros2",
        "genesys rqt"
      ]
    }
  },
  {
    "slug": "/dive-deeper/cpp",
    "title": "C++ Development & Macros",
    "description": "",
    "content": "# C++ Development with the `genesys_macros` Package\n\nThe `genesys_macros` package is an auxiliary ROS 2 package provided with the Genesys toolkit. It offers a straightforward, header-only macro system designed to rapidly scaffold simple C++ nodes. This provides an alternative to more complex, feature-rich node-authoring systems and is ideal for quick prototyping or for developers who prefer a more direct, file-based approach to node creation.\n\n## Package Structure\n\nThe `genesys_macros` package is a standard ROS 2 `ament_cmake` package with the following key files:\n\n* **`package.xml`**: Defines the package name (`genesys_macros`), dependencies, and build information. It depends on `ament_cmake`.\n* **`CMakeLists.txt`**: Contains the build logic. It finds necessary dependencies and ensures the `include` directory is correctly exported, making the macros available to other packages that depend on it.\n* **`include/genesys_macros/`**: This directory contains the header files where the macros are defined.\n  * `PublisherMacro.hpp`: Contains macros for creating basic nodes, nodes with timers, and publishing nodes.\n  * `SubscriberMacro.hpp`: Contains a \"universal\" macro for creating flexible nodes, often used for subscribers.\n\n## Macro Usage Guide\n\nThe following macros are designed to generate entire C++ class definitions and, in some cases, the `main()` entrypoint.\n\n***\n\n### `ROS_NODE_CLASS(NODE_NAME)`\n\n* **Header**: `PublisherMacro.hpp`\n* **Purpose**: Creates a minimal `rclcpp::Node` class. It generates a constructor that logs a startup message.\n* **Parameters**:\n  * `NODE_NAME`: The name for the C++ class and the ROS node.\n* **Example**:\n\n  ```cpp\n  #include \"genesys_macros/PublisherMacro.hpp\"\n\n  // This expands into a class named 'MySimpleNode'\n  ROS_NODE_CLASS(MySimpleNode)\n\n  // You still need a main function to run it\n  int main(int argc, char* argv[])\n  {\n      rclcpp::init(argc, argv);\n      rclcpp::spin(std::make_shared<MySimpleNode>());\n      rclcpp::shutdown();\n      return 0;\n  }\n  ```\n\n***\n\n### `ROS_NODE_WITH_TIMER(NODE_NAME, TIMER_MS, CALLBACK_FN)`\n\n* **Header**: `PublisherMacro.hpp`\n* **Purpose**: Generates a node containing a recurring wall timer that triggers a callback function.\n* **Parameters**:\n  * `NODE_NAME`: The name for the C++ class and the ROS node.\n  * `TIMER_MS`: The period of the timer in milliseconds.\n  * `CALLBACK_FN`: The name of the member function to be called by the timer. **You must provide the implementation for this function.**\n* **Example**:\n\n  ```cpp\n  #include \"genesys_macros/PublisherMacro.hpp\"\n\n  // Generates class 'MyTimerNode' with a 500ms timer\n  ROS_NODE_WITH_TIMER(MyTimerNode, 500, timer_callback)\n\n  // You must implement the callback\n  void MyTimerNode::timer_callback()\n  {\n      RCLCPP_INFO(this->get_logger(), \"Timer fired!\");\n  }\n\n  // Main function needed to run\n  ROS_NODE_MAIN(MyTimerNode)\n  ```\n\n***\n\n### `ROS_PUBLISHING_NODE(NODE_NAME, TOPIC, MSG_TYPE, TIMER_MS, CALLBACK_FN)`\n\n* **Header**: `PublisherMacro.hpp`\n* **Purpose**: Generates a node that includes a publisher and a timer. The timer's callback is intended to be used for publishing messages.\n* **Parameters**:\n  * `NODE_NAME`: The name for the C++ class and the ROS node.\n  * `TOPIC`: A string literal for the topic name (e.g., `\"chatter\"`).\n  * `MSG_TYPE`: The message type (e.g., `std_msgs::msg::String`).\n  * `TIMER_MS`: The period of the timer in milliseconds.\n  * `CALLBACK_FN`: The name of the callback function where you can access the `publisher_` member to send messages. **You must implement this function.**\n* **Example**:\n\n  ```cpp\n  #include \"genesys_macros/PublisherMacro.hpp\"\n  #include \"std_msgs/msg/string.hpp\"\n\n  ROS_PUBLISHING_NODE(MyPublisher, \"hello_world\", std_msgs::msg::String, 1000, publish_message)\n\n  void MyPublisher::publish_message()\n  {\n      auto msg = std::make_unique<std_msgs::msg::String>();\n      msg->data = \"Hello from the macro!\";\n      publisher_->publish(std::move(msg)); // 'publisher_' is a member of the generated class\n  }\n\n  ROS_NODE_MAIN(MyPublisher)\n  ```\n\n***\n\n### `ROS_UNIVERSAL_NODE(NODE_NAME, DECLARATIONS, INITIALIZERS)`\n\n* **Header**: `SubscriberMacro.hpp`\n* **Purpose**: A highly flexible macro for defining a node with custom member variables and constructor logic. It is particularly useful for creating subscribers or other complex nodes.\n* **Parameters**:\n  * `NODE_NAME`: The name for the C++ class and the ROS node.\n  * `DECLARATIONS`: A block of C++ code for declaring member variables (like publishers, subscribers, timers) and member function prototypes.\n  * `INITIALIZERS`: A block of C++ code that will be placed inside the node's constructor to initialize the members defined in `DECLARATIONS`.\n* **Example (Subscriber)**:\n\n  ```cpp\n  #include \"genesys_macros/SubscriberMacro.hpp\"\n  #include \"std_msgs/msg/string.hpp\"\n\n  ROS_UNIVERSAL_NODE(\n      MySubscriber,\n      // --- Declarations ---\n      rclcpp::Subscription<std_msgs::msg::String>::SharedPtr sub_;\n      void topic_callback(const std_msgs::msg::String::SharedPtr msg);\n      , // Note the comma separating the blocks\n      // --- Initializers ---\n      sub_ = this->create_subscription<std_msgs::msg::String>(\n          \"hello_world\", 10, std::bind(&MySubscriber::topic_callback, this, std::placeholders::_1));\n  )\n\n  // You must implement the callback function\n  void MySubscriber::topic_callback(const std_msgs::msg::String::SharedPtr msg)\n  {\n      RCLCPP_INFO(this->get_logger(), \"I heard: '%s'\", msg->data.c_str());\n  }\n\n  ROS_NODE_MAIN(MySubscriber)\n  ```\n\n***\n\n### `ROS_NODE_MAIN(NODE_NAME)`\n\n* **Header**: `PublisherMacro.hpp`\n* **Purpose**: Generates the standard `main()` function entrypoint needed to run a ROS 2 node. It handles `rclcpp::init`, `rclcpp::spin`, and `rclcpp::shutdown`.\n* **Parameters**:\n  * `NODE_NAME`: The name of the node class to instantiate and spin.\n* **Example**:\n\n  ```cpp\n  #include \"genesys_macros/PublisherMacro.hpp\"\n\n  // Define your node class first\n  ROS_NODE_CLASS(MyAwesomeNode)\n\n  // This expands into the main() function for MyAwesomeNode\n  ROS_NODE_MAIN(MyAwesomeNode)\n  ```\n",
    "_searchMeta": {
      "cleanContent": "c development with the genesys_macros package the genesys_macros package is an auxiliary ros 2 package provided with the genesys toolkit it offers a straightforward header-only macro system designed to rapidly scaffold simple c nodes this provides an alternative to more complex feature-rich node-authoring systems and is ideal for quick prototyping or for developers who prefer a more direct file-based approach to node creation package structure the genesysmacros package is a standard ros 2 amentcmake package with the following key files: package xml: defines the package name genesysmacros dependencies and build information it depends on amentcmake cmakelists txt: contains the build logic it finds necessary dependencies and ensures the include directory is correctly exported making the macros available to other packages that depend on it include genesys_macros : this directory contains the header files where the macros are defined publishermacro hpp: contains macros for creating basic nodes nodes with timers and publishing nodes subscribermacro hpp: contains a universal macro for creating flexible nodes often used for subscribers macro usage guide the following macros are designed to generate entire c class definitions and in some cases the main entrypoint rosnodeclass node_name header: publishermacro hpp purpose: creates a minimal rclcpp::node class it generates a constructor that logs a startup message parameters: node_name: the name for the c class and the ros node example: rosnodewithtimer nodename timerms callbackfn header: publishermacro hpp purpose: generates a node containing a recurring wall timer that triggers a callback function parameters: node_name: the name for the c class and the ros node timer_ms: the period of the timer in milliseconds callback_fn: the name of the member function to be called by the timer you must provide the implementation for this function example: rospublishingnode nodename topic msgtype timerms callbackfn header: publishermacro hpp purpose: generates a node that includes a publisher and a timer the timer s callback is intended to be used for publishing messages parameters: node_name: the name for the c class and the ros node topic: a string literal for the topic name e g chatter msgtype: the message type e g stdmsgs::msg::string timer_ms: the period of the timer in milliseconds callbackfn: the name of the callback function where you can access the publisher member to send messages you must implement this function example: rosuniversalnode node_name declarations initializers header: subscribermacro hpp purpose: a highly flexible macro for defining a node with custom member variables and constructor logic it is particularly useful for creating subscribers or other complex nodes parameters: node_name: the name for the c class and the ros node declarations: a block of c code for declaring member variables like publishers subscribers timers and member function prototypes initializers: a block of c code that will be placed inside the node s constructor to initialize the members defined in declarations example subscriber : rosnodemain node_name header: publishermacro hpp purpose: generates the standard main function entrypoint needed to run a ros 2 node it handles rclcpp::init rclcpp::spin and rclcpp::shutdown parameters: node_name: the name of the node class to instantiate and spin example:",
      "headings": [
        "Package Structure",
        "Macro Usage Guide"
      ],
      "keywords": [
        "Package Structure",
        "Macro Usage Guide",
        "`package.xml`",
        "`CMakeLists.txt`",
        "`include/genesys_macros/`",
        "Header",
        "Purpose",
        "Parameters",
        "Example",
        "You must provide the implementation for this function.",
        "You must implement this function.",
        "Example (Subscriber)",
        "genesys_macros",
        "ament_cmake",
        "package.xml",
        "CMakeLists.txt",
        "include",
        "include/genesys_macros/",
        "PublisherMacro.hpp",
        "SubscriberMacro.hpp",
        "main()",
        "ROS_NODE_CLASS(NODE_NAME)",
        "rclcpp::Node",
        "NODE_NAME",
        "cpp\n  #include \"genesys_macros/PublisherMacro.hpp\"\n\n  // This expands into a class named 'MySimpleNode'\n  ROS_NODE_CLASS(MySimpleNode)\n\n  // You still need a main function to run it\n  int main(int argc, char* argv[])\n  {\n      rclcpp::init(argc, argv);\n      rclcpp::spin(std::make_shared<MySimpleNode>());\n      rclcpp::shutdown();\n      return 0;\n  }",
        "***\n\n###",
        "* **Header**:",
        "* **Purpose**: Generates a node containing a recurring wall timer that triggers a callback function.\n* **Parameters**:\n  *",
        ": The name for the C++ class and the ROS node.\n  *",
        ": The period of the timer in milliseconds.\n  *",
        ": The name of the member function to be called by the timer. **You must provide the implementation for this function.**\n* **Example**:",
        "cpp\n  #include \"genesys_macros/PublisherMacro.hpp\"\n\n  // Generates class 'MyTimerNode' with a 500ms timer\n  ROS_NODE_WITH_TIMER(MyTimerNode, 500, timer_callback)\n\n  // You must implement the callback\n  void MyTimerNode::timer_callback()\n  {\n      RCLCPP_INFO(this->get_logger(), \"Timer fired!\");\n  }\n\n  // Main function needed to run\n  ROS_NODE_MAIN(MyTimerNode)",
        "* **Purpose**: Generates a node that includes a publisher and a timer. The timer's callback is intended to be used for publishing messages.\n* **Parameters**:\n  *",
        ": A string literal for the topic name (e.g.,",
        ").\n  *",
        ": The message type (e.g.,",
        ": The name of the callback function where you can access the",
        "member to send messages. **You must implement this function.**\n* **Example**:",
        "cpp\n  #include \"genesys_macros/PublisherMacro.hpp\"\n  #include \"std_msgs/msg/string.hpp\"\n\n  ROS_PUBLISHING_NODE(MyPublisher, \"hello_world\", std_msgs::msg::String, 1000, publish_message)\n\n  void MyPublisher::publish_message()\n  {\n      auto msg = std::make_unique<std_msgs::msg::String>();\n      msg->data = \"Hello from the macro!\";\n      publisher_->publish(std::move(msg)); // 'publisher_' is a member of the generated class\n  }\n\n  ROS_NODE_MAIN(MyPublisher)",
        "* **Purpose**: A highly flexible macro for defining a node with custom member variables and constructor logic. It is particularly useful for creating subscribers or other complex nodes.\n* **Parameters**:\n  *",
        ": A block of C++ code for declaring member variables (like publishers, subscribers, timers) and member function prototypes.\n  *",
        ": A block of C++ code that will be placed inside the node's constructor to initialize the members defined in",
        ".\n* **Example (Subscriber)**:",
        "cpp\n  #include \"genesys_macros/SubscriberMacro.hpp\"\n  #include \"std_msgs/msg/string.hpp\"\n\n  ROS_UNIVERSAL_NODE(\n      MySubscriber,\n      // --- Declarations ---\n      rclcpp::Subscription<std_msgs::msg::String>::SharedPtr sub_;\n      void topic_callback(const std_msgs::msg::String::SharedPtr msg);\n      , // Note the comma separating the blocks\n      // --- Initializers ---\n      sub_ = this->create_subscription<std_msgs::msg::String>(\n          \"hello_world\", 10, std::bind(&MySubscriber::topic_callback, this, std::placeholders::_1));\n  )\n\n  // You must implement the callback function\n  void MySubscriber::topic_callback(const std_msgs::msg::String::SharedPtr msg)\n  {\n      RCLCPP_INFO(this->get_logger(), \"I heard: '%s'\", msg->data.c_str());\n  }\n\n  ROS_NODE_MAIN(MySubscriber)",
        "* **Purpose**: Generates the standard",
        "function entrypoint needed to run a ROS 2 node. It handles",
        ",",
        ", and",
        ".\n* **Parameters**:\n  *",
        ": The name of the node class to instantiate and spin.\n* **Example**:",
        "cpp\n  #include \"genesys_macros/PublisherMacro.hpp\"\n\n  // Define your node class first\n  ROS_NODE_CLASS(MyAwesomeNode)\n\n  // This expands into the main() function for MyAwesomeNode\n  ROS_NODE_MAIN(MyAwesomeNode)"
      ]
    }
  },
  {
    "slug": "/dive-deeper/decorators",
    "title": "Decorators",
    "description": "",
    "content": "# Genesys Python API: Decorators and Declarative Nodes\n\nThe Genesys framework provides a powerful, declarative Python API for creating ROS 2 nodes. Instead of writing boilerplate `__init__` methods to manually create publishers, subscribers, and other ROS entities, you can simply decorate your classes and methods to define their behavior.\n\nThis document provides a comprehensive guide to the entire Python API, from the core decorators to advanced features like lifecycle nodes and dynamic configuration.\n\n## How It Works: The `NodeBase` Engine\n\nThe magic behind the declarative API is the `genesys.node_base.NodeBase` class. When you apply the top-level `@node` decorator to your class, Genesys wraps your class in a `NodeBase` instance. Here‚Äôs a high-level overview of the process:\n\n1. **Instantiation:** The `NodeBase` wrapper is instantiated, creating an instance of your user-defined class within it.\n2. **Injection:** `NodeBase` injects useful ROS 2 utilities into your class instance, making `self.logger` (for logging) and `self.get_clock` available.\n3. **Inspection:** `NodeBase` uses Python's `inspect` module to scan all of your class's methods and attributes.\n4. **Discovery:** It looks for special metadata attached by the Genesys decorators (e.g., a method decorated with `@subscriber` will have a `_ros_subscribers` attribute). It also finds declarative attributes like `parameter()` and `action_client()`.\n5. **Wiring:** Based on the discovered metadata, `NodeBase` automatically:\n   * Creates all the necessary ROS 2 publishers, subscribers, timers, services, and action servers.\n   * Connects them to the correct callback methods in your class.\n   * Initializes ROS 2 parameters and sets up automatic updates.\n   * Creates action clients.\n   * Wraps methods where necessary (e.g., for publishers) to handle return values.\n\nThis automated setup significantly reduces boilerplate code and lets you focus purely on the logic of your node.\n\n***\n\n## The Top-Level `@node` Decorator\n\nThis is the main entry point for creating a Genesys node. It must be applied to the class you intend to run as a node.\n\n```python\nfrom genesys.decorators import node\r\n\r\n@node('my_first_node')\r\nclass MyNode:\r\n    # ... your logic here ...\n```\n\n### Parameters\n\n* **`node_name`** (str): The name of the ROS 2 node.\n\n### How It Works\n\nThe `@node` decorator is responsible for creating the `NodeBase` wrapper around your class. It determines whether to create a standard `rclpy.node.Node` or a `rclpy.lifecycle.LifecycleNode` based on whether the `@lifecycle_node` decorator is also present.\n\n***\n\n## Communication Decorators\n\nThese decorators are used on methods within your `@node`-decorated class to set up ROS 2 communication channels.\n\n### `@publisher(topic, msg_type, qos=\"default\")`\n\nDecorates a method that produces messages. The decorated method's return value will be automatically published to the specified topic.\n\n* **`topic`** (str | `Parameter`): The name of the topic to publish to. Can be a string or a `Parameter` for dynamic configuration.\n* **`msg_type`**: The ROS 2 message type (e.g., `std_msgs.msg.String`).\n* **`qos`**: A QoS profile. Can be a `QoSProfile` object or a string alias (see QoS section).\n\n**Example:**\n\n```python\nfrom std_msgs.msg import String\r\nfrom genesys.decorators import publisher, timer\r\n\r\n@timer(1.0)\r\n@publisher('/my_topic', String)\r\ndef publish_message(self):\r\n    msg = String()\r\n    msg.data = f'Current time: {self.get_clock().now()}'\r\n    return msg # This return value is published\n```\n\n#### How It Works\n\nThe `@publisher` decorator attaches metadata to the `publish_message` method. When `NodeBase` finds this, it creates a `rclpy.Publisher`. It then *wraps* the original `publish_message` method. The wrapper function calls your original method, and if the return value is not `None`, it calls `publish()` on it. The `@timer` decorator then uses this wrapped function as its callback.\n\n### `@subscriber(topic, msg_type, qos=\"default\", debug_log=False)`\n\nDecorates a method that will be used as a callback for a topic subscription.\n\n* **`topic`** (str | `Parameter`): The name of the topic to subscribe to.\n* **`msg_type`**: The ROS 2 message type.\n* **`qos`**: The QoS profile or string alias.\n* **`debug_log`** (bool): If `True`, a `DEBUG` level log message will be printed every time a message is received.\n\n**Example:**\n\n```python\nfrom std_msgs.msg import String\r\nfrom genesys.decorators import subscriber\r\n\r\n@subscriber('/my_topic', String)\r\ndef topic_callback(self, msg: String):\r\n    self.logger.info(f'I heard: \"{msg.data}\"')\n```\n\n#### How It Works\n\n`NodeBase` discovers the `_ros_subscribers` metadata on the `topic_callback` method and calls `self.create_subscription()`, passing the method itself as the callback. If `debug_log` is enabled, it first wraps the callback in a function that logs the event.\n\n### `@timer(period_sec)`\n\nDecorates a method to be called at a fixed interval.\n\n* **`period_sec`** (float): The timer period in seconds.\n\n**Example:**\n\n```python\nfrom genesys.decorators import timer\r\n\r\n@timer(2.5)\r\ndef periodic_task(self):\r\n    self.logger.info('This runs every 2.5 seconds.')\n```\n\n#### How It Works\n\n`NodeBase` finds the `_ros_timers` metadata and calls `self.create_timer()`, passing the decorated method as the callback.\n\n### `@service(service_name, service_type)`\n\nDecorates a method to act as a callback for a ROS 2 service. The method signature must include `request` and `response` arguments.\n\n* **`service_name`** (str | `Parameter`): The name of the service.\n* **`service_type`**: The ROS 2 service type (e.g., `std_srvs.srv.SetBool`).\n\n**Example:**\n\n```python\nfrom std_srvs.srv import SetBool\r\nfrom genesys.decorators import service\r\n\r\n@service('my_service', SetBool)\r\ndef service_callback(self, request: SetBool.Request, response: SetBool.Response):\r\n    self.logger.info(f'Request received: {request.data}')\r\n    response.success = True\r\n    response.message = \"Processed!\"\r\n    return response # Must return the response object\n```\n\n### `@action_server(action_name, action_type)`\n\nDecorates a method to act as the `execute_callback` for a ROS 2 action server.\n\n* **`action_name`** (str | `Parameter`): The name of the action.\n* **`action_type`**: The ROS 2 action type (e.g., `nav2_msgs.action.NavigateToPose`).\n\n**Example:**\n\n```python\nimport time\r\nfrom geometry_msgs.msg import PoseStamped\r\nfrom nav2_msgs.action import NavigateToPose\r\nfrom genesys.decorators import action_server\r\n\r\n@action_server('navigate_to_pose', NavigateToPose)\r\ndef execute_nav(self, goal_handle):\r\n    self.logger.info('Executing goal...')\r\n\r\n    # Publish feedback\r\n    feedback_msg = NavigateToPose.Feedback()\r\n    feedback_msg.current_pose = PoseStamped() # Dummy feedback\r\n    goal_handle.publish_feedback(feedback_msg)\r\n\r\n    # Check for cancellation\r\n    if goal_handle.is_cancel_requested:\r\n        goal_handle.canceled()\r\n        self.logger.info('Goal canceled')\r\n        return NavigateToPose.Result()\r\n\r\n    time.sleep(2) # Simulate work\r\n\r\n    goal_handle.succeed()\r\n    self.logger.info('Goal succeeded!')\r\n    \r\n    result = NavigateToPose.Result()\r\n    return result\n```\n\n***\n\n## Component and Lifecycle Decorators\n\n### `@component`\n\nA **class decorator** that marks a Python class as a ROS 2 component, making it discoverable by component containers.\n\n**Example:**\n\n```python\nfrom genesys.decorators import component, node\r\n\r\n@node('my_component_node')\r\n@component\r\nclass MyImageProcessor:\r\n    # ... node logic using other decorators ...\n```\n\n#### How It Works\n\nThe `@component` decorator does two things:\n\n1. It sets a `__genesys_is_component__` flag on the class.\n2. It adds a static method `get_node_factory` to your class, which is required by the `rclpy_components` infrastructure to load the node.\n\nWhen you use `genesys make component`, the scaffolding tool automatically adds the necessary `entry_point` to your `setup.py` file to register this component.\n\n### `@lifecycle_node`\n\nA **class decorator** that transforms a standard node into a [Lifecycle Node](https://design.ros2.org/articles/node_lifecycle.html).\n\n**Example:**\n\n```python\nfrom genesys.decorators import lifecycle_node, node\r\n\r\n@node('my_lifecycle_node')\r\n@lifecycle_node\r\nclass MyLifecycleNode:\r\n    # ... on_configure, on_activate, etc. callbacks ...\n```\n\n#### How It Works\n\nThis decorator simply adds an `_is_lifecycle_node` flag to the class. The main `@node` decorator checks for this flag and, if present, makes the `NodeBase` wrapper inherit from `rclpy.lifecycle.LifecycleNode` instead of the standard `rclpy.node.Node`. You are then responsible for implementing the standard lifecycle transition callbacks (e.g., `on_configure`, `on_activate`).\n\n***\n\n## Declarative Attributes\n\nBesides decorators, Genesys provides functions to declaratively create attributes like parameters and action clients.\n\n### `parameter(name, default_value=None)`\n\nDeclares a ROS 2 parameter as a class attribute.\n\n* **`name`** (str): The ROS 2 parameter name.\n* **`default_value`**: The default value for the parameter.\n\n**Example:**\n\n```python\nfrom genesys.decorators import node, parameter, timer, publisher\r\nfrom std_msgs.msg import String\r\n\r\n@node('param_node')\r\nclass ParameterExample:\r\n    # Declare a parameter. The type is inferred from the type hint.\r\n    timer_period: float = parameter('timer_period_sec', 1.0)\r\n    \r\n    # Declare a parameter to be used as a topic name\r\n    output_topic: str = parameter('output_topic_name', '/default_topic')\r\n\r\n    def __init__(self):\r\n        # The parameter is available at self.timer_period\r\n        # We can now create a timer manually if its period needs to be dynamic\r\n        self.create_timer(self.timer_period, self._do_work)\r\n\r\n    @publisher(output_topic, String) # Use the parameter for the topic name\r\n    def _do_work(self):\r\n        return String(data=\"Hello from a dynamic topic!\")\n```\n\n#### How It Works\n\nThe `parameter()` function returns a special `Parameter` object. `NodeBase` discovers these objects during initialization. It uses the attribute's name (`timer_period`) and type hint (`float`) to call `self.declare_parameter()`. It also sets up a callback so that if the ROS 2 parameter is changed externally (e.g., with `ros2 param set`), the attribute `self.timer_period` on your class instance is **automatically updated**.\n\n### `action_client(name, action_type)`\n\nDeclares a ROS 2 action client as a class attribute.\n\n* **`name`** (str | `Parameter`): The name of the action.\n* **`action_type`**: The ROS 2 action type.\n\n**Example:**\n\n```python\nfrom genesys.decorators import node, action_client\r\nfrom nav2_msgs.action import NavigateToPose\r\n\r\n@node('action_client_node')\r\nclass MyActionClient:\r\n    nav_client = action_client('navigate_to_pose', NavigateToPose)\r\n\r\n    def send_goal(self):\r\n        if not self.nav_client.wait_for_server(timeout_sec=1.0):\r\n            self.logger.error('Action server not available!')\r\n            return\r\n\r\n        goal_msg = NavigateToPose.Goal()\r\n        # ... populate goal_msg ...\r\n\r\n        self.logger.info('Sending goal request...')\r\n        self.nav_client.send_goal_async(goal_msg)\n```\n\n#### How It Works\n\nSimilar to `parameter()`, `action_client()` returns a placeholder object. `NodeBase` finds this placeholder, creates a real `rclpy.action.ActionClient`, and replaces the placeholder attribute (`self.nav_client`) with the actual, ready-to-use client.\n\n***\n\n## Quality of Service (QoS) Aliases\n\nFor convenience, all decorators that accept a `qos` argument can take one of the following string aliases instead of a full `QoSProfile` object:\n\n* **`\"default\"`**: `RELIABLE`, `KEEP_LAST`, `depth=10`. Good for most use cases.\n* **`\"sensor\"`**: `BEST_EFFORT`, `KEEP_LAST`, `depth=1`. Ideal for high-frequency sensor data where it's okay to drop messages.\n* **`\"system\"`**: The default ROS 2 system profile (`rclpy.qos.qos_profile_system_default`).\n* **`\"services\"`**: The default ROS 2 services profile (`rclpy.qos.qos_profile_services_default`).\n",
    "_searchMeta": {
      "cleanContent": "genesys python api: decorators and declarative nodes the genesys framework provides a powerful declarative python api for creating ros 2 nodes instead of writing boilerplate _init_ methods to manually create publishers subscribers and other ros entities you can simply decorate your classes and methods to define their behavior this document provides a comprehensive guide to the entire python api from the core decorators to advanced features like lifecycle nodes and dynamic configuration how it works: the nodebase engine the magic behind the declarative api is the genesys node_base nodebase class when you apply the top-level node decorator to your class genesys wraps your class in a nodebase instance here s a high-level overview of the process: instantiation: the nodebase wrapper is instantiated creating an instance of your user-defined class within it injection: nodebase injects useful ros 2 utilities into your class instance making self logger for logging and self get_clock available inspection: nodebase uses python s inspect module to scan all of your class s methods and attributes discovery: it looks for special metadata attached by the genesys decorators e g a method decorated with subscriber will have a rossubscribers attribute it also finds declarative attributes like parameter and action_client wiring: based on the discovered metadata nodebase automatically: creates all the necessary ros 2 publishers subscribers timers services and action servers connects them to the correct callback methods in your class initializes ros 2 parameters and sets up automatic updates creates action clients wraps methods where necessary e g for publishers to handle return values this automated setup significantly reduces boilerplate code and lets you focus purely on the logic of your node the top-level node decorator this is the main entry point for creating a genesys node it must be applied to the class you intend to run as a node parameters node_name str : the name of the ros 2 node how it works the node decorator is responsible for creating the nodebase wrapper around your class it determines whether to create a standard rclpy node node or a rclpy lifecycle lifecyclenode based on whether the lifecycle_node decorator is also present communication decorators these decorators are used on methods within your node-decorated class to set up ros 2 communication channels publisher topic msg_type qos default decorates a method that produces messages the decorated method s return value will be automatically published to the specified topic topic str parameter : the name of the topic to publish to can be a string or a parameter for dynamic configuration msgtype: the ros 2 message type e g stdmsgs msg string qos: a qos profile can be a qosprofile object or a string alias see qos section example: how it works the publisher decorator attaches metadata to the publishmessage method when nodebase finds this it creates a rclpy publisher it then wraps the original publishmessage method the wrapper function calls your original method and if the return value is not none it calls publish on it the timer decorator then uses this wrapped function as its callback subscriber topic msgtype qos default debuglog false decorates a method that will be used as a callback for a topic subscription topic str parameter : the name of the topic to subscribe to msg_type: the ros 2 message type qos: the qos profile or string alias debug_log bool : if true a debug level log message will be printed every time a message is received example: how it works nodebase discovers the rossubscribers metadata on the topiccallback method and calls self createsubscription passing the method itself as the callback if debug_log is enabled it first wraps the callback in a function that logs the event timer period_sec decorates a method to be called at a fixed interval period_sec float : the timer period in seconds example: how it works nodebase finds the rostimers metadata and calls self create_timer passing the decorated method as the callback service servicename servicetype decorates a method to act as a callback for a ros 2 service the method signature must include request and response arguments service_name str parameter : the name of the service servicetype: the ros 2 service type e g stdsrvs srv setbool example: actionserver actionname action_type decorates a method to act as the execute_callback for a ros 2 action server action_name str parameter : the name of the action actiontype: the ros 2 action type e g nav2msgs action navigatetopose example: component and lifecycle decorators component a class decorator that marks a python class as a ros 2 component making it discoverable by component containers example: how it works the component decorator does two things: it sets a _genesysiscomponent_ flag on the class it adds a static method getnodefactory to your class which is required by the rclpy_components infrastructure to load the node when you use genesys make component the scaffolding tool automatically adds the necessary entry_point to your setup py file to register this component lifecycle_node a class decorator that transforms a standard node into a lifecycle node example: how it works this decorator simply adds an islifecyclenode flag to the class the main node decorator checks for this flag and if present makes the nodebase wrapper inherit from rclpy lifecycle lifecyclenode instead of the standard rclpy node node you are then responsible for implementing the standard lifecycle transition callbacks e g onconfigure on_activate declarative attributes besides decorators genesys provides functions to declaratively create attributes like parameters and action clients parameter name default_value none declares a ros 2 parameter as a class attribute name str : the ros 2 parameter name default_value: the default value for the parameter example: how it works the parameter function returns a special parameter object nodebase discovers these objects during initialization it uses the attribute s name timerperiod and type hint float to call self declareparameter it also sets up a callback so that if the ros 2 parameter is changed externally e g with ros2 param set the attribute self timer_period on your class instance is automatically updated actionclient name actiontype declares a ros 2 action client as a class attribute name str parameter : the name of the action action_type: the ros 2 action type example: how it works similar to parameter actionclient returns a placeholder object nodebase finds this placeholder creates a real rclpy action actionclient and replaces the placeholder attribute self navclient with the actual ready-to-use client quality of service qos aliases for convenience all decorators that accept a qos argument can take one of the following string aliases instead of a full qosprofile object: default : reliable keep_last depth 10 good for most use cases sensor : besteffort keeplast depth 1 ideal for high-frequency sensor data where it s okay to drop messages system : the default ros 2 system profile rclpy qos qosprofilesystem_default services : the default ros 2 services profile rclpy qos qosprofileservices_default",
      "headings": [
        "How It Works: The `NodeBase` Engine",
        "The Top-Level `@node` Decorator",
        "Communication Decorators",
        "Component and Lifecycle Decorators",
        "Declarative Attributes",
        "Quality of Service (QoS) Aliases"
      ],
      "keywords": [
        "How It Works: The `NodeBase` Engine",
        "The Top-Level `@node` Decorator",
        "Communication Decorators",
        "Component and Lifecycle Decorators",
        "Declarative Attributes",
        "Quality of Service (QoS) Aliases",
        "Instantiation:",
        "Injection:",
        "Inspection:",
        "Discovery:",
        "Wiring:",
        "`node_name`",
        "`topic`",
        "`msg_type`",
        "`qos`",
        "Example:",
        "`debug_log`",
        "`period_sec`",
        "`service_name`",
        "`service_type`",
        "`action_name`",
        "`action_type`",
        "## Component and Lifecycle Decorators\n\n### `@component`\n\nA",
        "that marks a Python class as a ROS 2 component, making it discoverable by component containers.",
        "```python\nfrom genesys.decorators import component, node\r\n\r\n@node('my_component_node')\r\n@component\r\nclass MyImageProcessor:\r\n    # ... node logic using other decorators ...\n```\n\n#### How It Works\n\nThe `@component` decorator does two things:\n\n1. It sets a `__genesys_is_component__` flag on the class.\n2. It adds a static method `get_node_factory` to your class, which is required by the `rclpy_components` infrastructure to load the node.\n\nWhen you use `genesys make component`, the scaffolding tool automatically adds the necessary `entry_point` to your `setup.py` file to register this component.\n\n### `@lifecycle_node`\n\nA",
        "that transforms a standard node into a [Lifecycle Node](https://design.ros2.org/articles/node_lifecycle.html).",
        "```python\nfrom genesys.decorators import lifecycle_node, node\r\n\r\n@node('my_lifecycle_node')\r\n@lifecycle_node\r\nclass MyLifecycleNode:\r\n    # ... on_configure, on_activate, etc. callbacks ...\n```\n\n#### How It Works\n\nThis decorator simply adds an `_is_lifecycle_node` flag to the class. The main `@node` decorator checks for this flag and, if present, makes the `NodeBase` wrapper inherit from `rclpy.lifecycle.LifecycleNode` instead of the standard `rclpy.node.Node`. You are then responsible for implementing the standard lifecycle transition callbacks (e.g., `on_configure`, `on_activate`).",
        "`name`",
        "`default_value`",
        "automatically updated",
        "`\"default\"`",
        "`\"sensor\"`",
        "`\"system\"`",
        "`\"services\"`",
        "__init__",
        "NodeBase",
        "genesys.node_base.NodeBase",
        "@node",
        "self.logger",
        "self.get_clock",
        "inspect",
        "@subscriber",
        "_ros_subscribers",
        "parameter()",
        "action_client()",
        "python\nfrom genesys.decorators import node\r\n\r\n@node('my_first_node')\r\nclass MyNode:\r\n    # ... your logic here ...",
        "### Parameters\n\n* **",
        "** (str): The name of the ROS 2 node.\n\n### How It Works\n\nThe",
        "decorator is responsible for creating the",
        "wrapper around your class. It determines whether to create a standard",
        "or a",
        "based on whether the",
        "decorator is also present.\n\n***\n\n## Communication Decorators\n\nThese decorators are used on methods within your",
        "-decorated class to set up ROS 2 communication channels.\n\n###",
        "Decorates a method that produces messages. The decorated method's return value will be automatically published to the specified topic.\n\n* **",
        "** (str |",
        "): The name of the topic to publish to. Can be a string or a",
        "for dynamic configuration.\n* **",
        "**: The ROS 2 message type (e.g.,",
        ").\n* **",
        "**: A QoS profile. Can be a",
        "object or a string alias (see QoS section).\n\n**Example:**",
        "python\nfrom std_msgs.msg import String\r\nfrom genesys.decorators import publisher, timer\r\n\r\n@timer(1.0)\r\n@publisher('/my_topic', String)\r\ndef publish_message(self):\r\n    msg = String()\r\n    msg.data = f'Current time: {self.get_clock().now()}'\r\n    return msg # This return value is published",
        "#### How It Works\n\nThe",
        "decorator attaches metadata to the",
        "method. When",
        "finds this, it creates a",
        ". It then *wraps* the original",
        "method. The wrapper function calls your original method, and if the return value is not",
        ", it calls",
        "on it. The",
        "decorator then uses this wrapped function as its callback.\n\n###",
        "Decorates a method that will be used as a callback for a topic subscription.\n\n* **",
        "): The name of the topic to subscribe to.\n* **",
        "**: The ROS 2 message type.\n* **",
        "**: The QoS profile or string alias.\n* **",
        "** (bool): If",
        ", a",
        "level log message will be printed every time a message is received.\n\n**Example:**",
        "python\nfrom std_msgs.msg import String\r\nfrom genesys.decorators import subscriber\r\n\r\n@subscriber('/my_topic', String)\r\ndef topic_callback(self, msg: String):\r\n    self.logger.info(f'I heard: \"{msg.data}\"')",
        "#### How It Works",
        "discovers the",
        "metadata on the",
        "method and calls",
        ", passing the method itself as the callback. If",
        "is enabled, it first wraps the callback in a function that logs the event.\n\n###",
        "Decorates a method to be called at a fixed interval.\n\n* **",
        "** (float): The timer period in seconds.\n\n**Example:**",
        "python\nfrom genesys.decorators import timer\r\n\r\n@timer(2.5)\r\ndef periodic_task(self):\r\n    self.logger.info('This runs every 2.5 seconds.')",
        "finds the",
        "metadata and calls",
        ", passing the decorated method as the callback.\n\n###",
        "Decorates a method to act as a callback for a ROS 2 service. The method signature must include",
        "and",
        "arguments.\n\n* **",
        "): The name of the service.\n* **",
        "**: The ROS 2 service type (e.g.,",
        ").\n\n**Example:**",
        "python\nfrom std_srvs.srv import SetBool\r\nfrom genesys.decorators import service\r\n\r\n@service('my_service', SetBool)\r\ndef service_callback(self, request: SetBool.Request, response: SetBool.Response):\r\n    self.logger.info(f'Request received: {request.data}')\r\n    response.success = True\r\n    response.message = \"Processed!\"\r\n    return response # Must return the response object",
        "###",
        "Decorates a method to act as the",
        "for a ROS 2 action server.\n\n* **",
        "): The name of the action.\n* **",
        "**: The ROS 2 action type (e.g.,",
        "python\nimport time\r\nfrom geometry_msgs.msg import PoseStamped\r\nfrom nav2_msgs.action import NavigateToPose\r\nfrom genesys.decorators import action_server\r\n\r\n@action_server('navigate_to_pose', NavigateToPose)\r\ndef execute_nav(self, goal_handle):\r\n    self.logger.info('Executing goal...')\r\n\r\n    # Publish feedback\r\n    feedback_msg = NavigateToPose.Feedback()\r\n    feedback_msg.current_pose = PoseStamped() # Dummy feedback\r\n    goal_handle.publish_feedback(feedback_msg)\r\n\r\n    # Check for cancellation\r\n    if goal_handle.is_cancel_requested:\r\n        goal_handle.canceled()\r\n        self.logger.info('Goal canceled')\r\n        return NavigateToPose.Result()\r\n\r\n    time.sleep(2) # Simulate work\r\n\r\n    goal_handle.succeed()\r\n    self.logger.info('Goal succeeded!')\r\n    \r\n    result = NavigateToPose.Result()\r\n    return result",
        "***\n\n## Component and Lifecycle Decorators\n\n###",
        "A **class decorator** that marks a Python class as a ROS 2 component, making it discoverable by component containers.\n\n**Example:**",
        "python\nfrom genesys.decorators import component, node\r\n\r\n@node('my_component_node')\r\n@component\r\nclass MyImageProcessor:\r\n    # ... node logic using other decorators ...",
        "decorator does two things:\n\n1. It sets a",
        "flag on the class.\n2. It adds a static method",
        "to your class, which is required by the",
        "infrastructure to load the node.\n\nWhen you use",
        ", the scaffolding tool automatically adds the necessary",
        "to your",
        "file to register this component.\n\n###",
        "A **class decorator** that transforms a standard node into a [Lifecycle Node](https://design.ros2.org/articles/node_lifecycle.html).\n\n**Example:**",
        "python\nfrom genesys.decorators import lifecycle_node, node\r\n\r\n@node('my_lifecycle_node')\r\n@lifecycle_node\r\nclass MyLifecycleNode:\r\n    # ... on_configure, on_activate, etc. callbacks ...",
        "#### How It Works\n\nThis decorator simply adds an",
        "flag to the class. The main",
        "decorator checks for this flag and, if present, makes the",
        "wrapper inherit from",
        "instead of the standard",
        ". You are then responsible for implementing the standard lifecycle transition callbacks (e.g.,",
        ",",
        ").\n\n***\n\n## Declarative Attributes\n\nBesides decorators, Genesys provides functions to declaratively create attributes like parameters and action clients.\n\n###",
        "Declares a ROS 2 parameter as a class attribute.\n\n* **",
        "** (str): The ROS 2 parameter name.\n* **",
        "**: The default value for the parameter.\n\n**Example:**",
        "python\nfrom genesys.decorators import node, parameter, timer, publisher\r\nfrom std_msgs.msg import String\r\n\r\n@node('param_node')\r\nclass ParameterExample:\r\n    # Declare a parameter. The type is inferred from the type hint.\r\n    timer_period: float = parameter('timer_period_sec', 1.0)\r\n    \r\n    # Declare a parameter to be used as a topic name\r\n    output_topic: str = parameter('output_topic_name', '/default_topic')\r\n\r\n    def __init__(self):\r\n        # The parameter is available at self.timer_period\r\n        # We can now create a timer manually if its period needs to be dynamic\r\n        self.create_timer(self.timer_period, self._do_work)\r\n\r\n    @publisher(output_topic, String) # Use the parameter for the topic name\r\n    def _do_work(self):\r\n        return String(data=\"Hello from a dynamic topic!\")",
        "function returns a special",
        "object.",
        "discovers these objects during initialization. It uses the attribute's name (",
        ") and type hint (",
        ") to call",
        ". It also sets up a callback so that if the ROS 2 parameter is changed externally (e.g., with",
        "), the attribute",
        "on your class instance is **automatically updated**.\n\n###",
        "Declares a ROS 2 action client as a class attribute.\n\n* **",
        "**: The ROS 2 action type.\n\n**Example:**",
        "python\nfrom genesys.decorators import node, action_client\r\nfrom nav2_msgs.action import NavigateToPose\r\n\r\n@node('action_client_node')\r\nclass MyActionClient:\r\n    nav_client = action_client('navigate_to_pose', NavigateToPose)\r\n\r\n    def send_goal(self):\r\n        if not self.nav_client.wait_for_server(timeout_sec=1.0):\r\n            self.logger.error('Action server not available!')\r\n            return\r\n\r\n        goal_msg = NavigateToPose.Goal()\r\n        # ... populate goal_msg ...\r\n\r\n        self.logger.info('Sending goal request...')\r\n        self.nav_client.send_goal_async(goal_msg)",
        "#### How It Works\n\nSimilar to",
        "returns a placeholder object.",
        "finds this placeholder, creates a real",
        ", and replaces the placeholder attribute (",
        ") with the actual, ready-to-use client.\n\n***\n\n## Quality of Service (QoS) Aliases\n\nFor convenience, all decorators that accept a",
        "argument can take one of the following string aliases instead of a full",
        "object:\n\n* **",
        "**:",
        ". Good for most use cases.\n* **",
        ". Ideal for high-frequency sensor data where it's okay to drop messages.\n* **",
        "**: The default ROS 2 system profile (",
        "**: The default ROS 2 services profile ("
      ]
    }
  },
  {
    "slug": "/genesys-cli/build",
    "title": "Build Command",
    "description": "",
    "content": "title: CLI Command: `genesys build`\n\nThe `genesys build` command compiles your workspace using `colcon`, the standard build tool for ROS 2. It provides a convenient wrapper with helpful defaults and extra features.\n\ntitle:Usage\n\n```bash\ngenesys build [options]\n```\n\ntitle:Options\n\n* **`--packages <pkg1> <pkg2>...`** or **`-p <pkg1>...`**:\r\n  Build only the specified packages. If omitted, all packages in the workspace are built.\n\n* **`--persist`**:\r\n  After a successful build, this flag will add a command to source your workspace's `install/setup.bash` file to your shell's startup script (e.g., `~/.bashrc` or `~/.zshrc`).\n\ntitle:How It Works\n\n1. **Workspace Validation**: The command first checks that you are in the root of a Genesys workspace by looking for the `src/` directory.\n2. **Command Execution**: It then constructs and runs the following `colcon` command:\n   ```bash\n   colcon build --symlink-install --cmake-clean-first\n   ```\n   * `--symlink-install`: This is a crucial flag for rapid development. It creates symbolic links from the `install` directory to your source files instead of copying them. This means you can edit Python files and the changes will take effect immediately without needing to run `genesys build` again. (Note: You still need to rebuild if you add new files, messages, or change entry points in `setup.py`).\n   * `--cmake-clean-first`: This helps avoid issues with cached variables when you make significant changes to your `CMakeLists.txt` files, ensuring a cleaner and more reliable build.\n   * If you use the `--packages` option, it appends `--packages-select <pkg1> <pkg2>` to the command.\n3. **Real-time Output**: The output from the `colcon` command is streamed directly to your terminal in real-time, so you can monitor the build progress exactly as it happens.\n4. **Persistent Sourcing**: If you use the `--persist` flag, the tool will automatically perform the following action upon a successful build:\n   * It identifies your shell (`bash` or `zsh`).\n   * It appends a line like `source /path/to/your/project/install/setup.bash` to your `~/.bashrc` or `~/.zshrc` file.\n   * This is idempotent; it will not add the line if it already exists.\n   * This action makes your workspace's packages, nodes, and launch files automatically available in any new terminal you open.\n\ntitle:Examples\n\ntitle: Build the entire workspace\r\nThis is the most common use case.\n\n```bash\ngenesys build\n```\n\ntitle: Build specific packages\r\nUseful when you are working on a few packages in a large workspace.\n\n```bash\ngenesys build --packages my_package_1 my_package_2\n```\n\ntitle: Build and persist the workspace overlay\r\nA \"fire-and-forget\" command for a new workspace. After this, you can open a new terminal and your workspace will be ready to use.\n\n```bash\ngenesys build --persist\n```\n",
    "_searchMeta": {
      "cleanContent": "title: cli command: genesys build the genesys build command compiles your workspace using colcon the standard build tool for ros 2 it provides a convenient wrapper with helpful defaults and extra features title:usage title:options --packages pkg1 pkg2 or -p pkg1 : build only the specified packages if omitted all packages in the workspace are built --persist: after a successful build this flag will add a command to source your workspace s install setup bash file to your shell s startup script e g bashrc or zshrc title:how it works workspace validation: the command first checks that you are in the root of a genesys workspace by looking for the src directory command execution: it then constructs and runs the following colcon command: --symlink-install: this is a crucial flag for rapid development it creates symbolic links from the install directory to your source files instead of copying them this means you can edit python files and the changes will take effect immediately without needing to run genesys build again note: you still need to rebuild if you add new files messages or change entry points in setup py --cmake-clean-first: this helps avoid issues with cached variables when you make significant changes to your cmakelists txt files ensuring a cleaner and more reliable build if you use the --packages option it appends --packages-select pkg1 pkg2 to the command real-time output: the output from the colcon command is streamed directly to your terminal in real-time so you can monitor the build progress exactly as it happens persistent sourcing: if you use the --persist flag the tool will automatically perform the following action upon a successful build: it identifies your shell bash or zsh it appends a line like source path to your project install setup bash to your bashrc or zshrc file this is idempotent it will not add the line if it already exists this action makes your workspace s packages nodes and launch files automatically available in any new terminal you open title:examples title: build the entire workspace this is the most common use case title: build specific packages useful when you are working on a few packages in a large workspace title: build and persist the workspace overlay a fire-and-forget command for a new workspace after this you can open a new terminal and your workspace will be ready to use",
      "headings": [],
      "keywords": [
        "`--packages <pkg1> <pkg2>...`",
        "`-p <pkg1>...`",
        "`--persist`",
        "Workspace Validation",
        "Command Execution",
        "Real-time Output",
        "Persistent Sourcing",
        "genesys build",
        "colcon",
        "bash\ngenesys build [options]",
        "title:Options\n\n* **",
        "** or **",
        "**:\r\n  Build only the specified packages. If omitted, all packages in the workspace are built.\n\n* **",
        "**:\r\n  After a successful build, this flag will add a command to source your workspace's",
        "file to your shell's startup script (e.g.,",
        "or",
        ").\n\ntitle:How It Works\n\n1. **Workspace Validation**: The command first checks that you are in the root of a Genesys workspace by looking for the",
        "directory.\n2. **Command Execution**: It then constructs and runs the following",
        "command:",
        "bash\n   colcon build --symlink-install --cmake-clean-first",
        "*",
        ": This is a crucial flag for rapid development. It creates symbolic links from the",
        "directory to your source files instead of copying them. This means you can edit Python files and the changes will take effect immediately without needing to run",
        "again. (Note: You still need to rebuild if you add new files, messages, or change entry points in",
        ").\n   *",
        ": This helps avoid issues with cached variables when you make significant changes to your",
        "files, ensuring a cleaner and more reliable build.\n   * If you use the",
        "option, it appends",
        "to the command.\n3. **Real-time Output**: The output from the",
        "command is streamed directly to your terminal in real-time, so you can monitor the build progress exactly as it happens.\n4. **Persistent Sourcing**: If you use the",
        "flag, the tool will automatically perform the following action upon a successful build:\n   * It identifies your shell (",
        ").\n   * It appends a line like",
        "to your",
        "file.\n   * This is idempotent; it will not add the line if it already exists.\n   * This action makes your workspace's packages, nodes, and launch files automatically available in any new terminal you open.\n\ntitle:Examples\n\ntitle: Build the entire workspace\r\nThis is the most common use case.",
        "bash\ngenesys build",
        "title: Build specific packages\r\nUseful when you are working on a few packages in a large workspace.",
        "bash\ngenesys build --packages my_package_1 my_package_2",
        "title: Build and persist the workspace overlay\r\nA \"fire-and-forget\" command for a new workspace. After this, you can open a new terminal and your workspace will be ready to use.",
        "bash\ngenesys build --persist"
      ]
    }
  },
  {
    "slug": "/genesys-cli/cli-debug-tools",
    "title": "Debug Tooling",
    "description": "",
    "content": "# CLI: ROS 2 Wrappers\n\nGenesys provides a set of convenient wrappers around the most common `ros2` CLI command groups. These wrappers automatically source your local workspace's `install/setup.bash` file before executing the command, so you don't have to remember to do it yourself.\n\n## Why Use Them?\n\nThe main advantage is convenience. In a typical workflow, you might open a new terminal and forget to source your workspace overlay. If you then try to interact with a node or topic from your workspace using `ros2 topic echo`, it will likely fail.\n\nBy using the `genesys` wrappers (`genesys topic echo`), the command ensures the environment is correctly set up first, leading to fewer \"package not found\" or \"topic not found\" errors.\n\n## Usage\n\nYou can use these commands exactly like their `ros2` counterparts, but with `genesys` as the prefix.\n\n```bash\n# Instead of 'ros2 topic list'\r\ngenesys topic list\r\n\r\n# Instead of 'ros2 param get /my_node my_param'\r\ngenesys param get /my_node my_param\n```\n\n## Available Command Groups\n\n### `genesys node`\n\n* `list`: List all running nodes.\n* `info <node_name>`: Get information about a specific node.\n\n### `genesys topic`\n\n* `list`: List all active topics.\n* `info <topic_name>`: Get information about a specific topic.\n* `echo <topic_name>`: Echo messages from a topic.\n* `pub <topic_name> <msg_type> [args]`: Publish a message to a topic.\n* `bw <topic_name>`: Display bandwidth used by a topic.\n* `find <msg_type>`: Find topics by message type.\n* `record [topics...]`: Record topics to a bag file. Records all topics if none are specified.\n* `replay <bag_file>`: Play back a bag file.\n\n### `genesys service`\n\n* `list`: List all active services.\n* `type <srv_name>`: Get the type of a service.\n* `info <srv_name>`: Get information about a specific service.\n* `find <srv_type>`: Find services by service type.\n* `call <srv_name> <srv_type> [args]`: Call a service with the given arguments.\n\n### `genesys action`\n\n* `list`: List all active actions.\n* `type <action_name>`: Get the type of an action.\n* `info <action_name>`: Get information about a specific action.\n* `send_goal <action_name> <action_type> [args]`: Send a goal to an action server.\n\n### `genesys param`\n\n* `list [node_name]`: List parameters for a specific node or all nodes.\n* `get <node_name> <param_name>`: Get a parameter from a node.\n* `set <node_name> <param_name> <value>`: Set a parameter on a node.\n* `dump <node_name>`: Dump all parameters for a node to a YAML file.\n* `load <node_name> <file_path>`: Load parameters for a node from a file.\n\n***\n\n## Notes on Specific Commands\n\nSome commands have slightly different behavior or are not implemented.\n\n* **`genesys service info`**: The `ros2 service info` command does not exist. This wrapper is a convenience alias for `genesys service type`.\n* **`genesys action type`**: The `ros2 action type` command does not exist. This wrapper is a convenience alias for `genesys action info`.\n* **`genesys service echo`**: This feature is not implemented, as it would require a custom node to intercept and print service requests.\n* **`genesys action echo`**: This feature is not implemented, as it would require a custom node to monitor the action feedback and result topics.\n",
    "_searchMeta": {
      "cleanContent": "cli: ros 2 wrappers genesys provides a set of convenient wrappers around the most common ros2 cli command groups these wrappers automatically source your local workspace s install setup bash file before executing the command so you don t have to remember to do it yourself why use them the main advantage is convenience in a typical workflow you might open a new terminal and forget to source your workspace overlay if you then try to interact with a node or topic from your workspace using ros2 topic echo it will likely fail by using the genesys wrappers genesys topic echo the command ensures the environment is correctly set up first leading to fewer package not found or topic not found errors usage you can use these commands exactly like their ros2 counterparts but with genesys as the prefix available command groups genesys node list: list all running nodes info node_name : get information about a specific node genesys topic list: list all active topics info topic_name : get information about a specific topic echo topic_name : echo messages from a topic pub topicname msgtype args : publish a message to a topic bw topic_name : display bandwidth used by a topic find msg_type : find topics by message type record topics : record topics to a bag file records all topics if none are specified replay bag_file : play back a bag file genesys service list: list all active services type srv_name : get the type of a service info srv_name : get information about a specific service find srv_type : find services by service type call srvname srvtype args : call a service with the given arguments genesys action list: list all active actions type action_name : get the type of an action info action_name : get information about a specific action sendgoal actionname action_type args : send a goal to an action server genesys param list node_name : list parameters for a specific node or all nodes get nodename paramname : get a parameter from a node set nodename paramname value : set a parameter on a node dump node_name : dump all parameters for a node to a yaml file load nodename filepath : load parameters for a node from a file notes on specific commands some commands have slightly different behavior or are not implemented genesys service info: the ros2 service info command does not exist this wrapper is a convenience alias for genesys service type genesys action type: the ros2 action type command does not exist this wrapper is a convenience alias for genesys action info genesys service echo: this feature is not implemented as it would require a custom node to intercept and print service requests genesys action echo: this feature is not implemented as it would require a custom node to monitor the action feedback and result topics",
      "headings": [
        "Why Use Them?",
        "Usage",
        "Available Command Groups",
        "Notes on Specific Commands"
      ],
      "keywords": [
        "Why Use Them?",
        "Usage",
        "Available Command Groups",
        "Notes on Specific Commands",
        "`genesys service info`",
        "`genesys action type`",
        "`genesys service echo`",
        "`genesys action echo`",
        "ros2",
        "install/setup.bash",
        "ros2 topic echo",
        "genesys",
        "genesys topic echo",
        "bash\n# Instead of 'ros2 topic list'\r\ngenesys topic list\r\n\r\n# Instead of 'ros2 param get /my_node my_param'\r\ngenesys param get /my_node my_param",
        "## Available Command Groups\n\n###",
        "*",
        ": List all running nodes.\n*",
        ": Get information about a specific node.\n\n###",
        ": List all active topics.\n*",
        ": Get information about a specific topic.\n*",
        ": Echo messages from a topic.\n*",
        ": Publish a message to a topic.\n*",
        ": Display bandwidth used by a topic.\n*",
        ": Find topics by message type.\n*",
        ": Record topics to a bag file. Records all topics if none are specified.\n*",
        ": Play back a bag file.\n\n###",
        ": List all active services.\n*",
        ": Get the type of a service.\n*",
        ": Get information about a specific service.\n*",
        ": Find services by service type.\n*",
        ": Call a service with the given arguments.\n\n###",
        ": List all active actions.\n*",
        ": Get the type of an action.\n*",
        ": Get information about a specific action.\n*",
        ": Send a goal to an action server.\n\n###",
        ": List parameters for a specific node or all nodes.\n*",
        ": Get a parameter from a node.\n*",
        ": Set a parameter on a node.\n*",
        ": Dump all parameters for a node to a YAML file.\n*",
        ": Load parameters for a node from a file.\n\n***\n\n## Notes on Specific Commands\n\nSome commands have slightly different behavior or are not implemented.\n\n* **",
        "**: The",
        "command does not exist. This wrapper is a convenience alias for",
        ".\n* **",
        "**: This feature is not implemented, as it would require a custom node to intercept and print service requests.\n* **"
      ]
    }
  },
  {
    "slug": "/genesys-cli/doctor",
    "title": "Doctor Command",
    "description": "",
    "content": "# CLI Command: `genesys doctor`\n\nThe `genesys doctor` command is a diagnostic tool that checks your local environment for common configuration problems that could prevent Genesys or ROS 2 from working correctly.\n\nIt's a good first step for troubleshooting your development environment.\n\n## Usage\n\n```bash\ngenesys doctor\n```\n\n## Checks Performed\n\nThe doctor runs the following checks in order.\n\n***\n\n### 1. `PATH` Configuration\n\nThis check ensures that you can run `genesys` and other Python-installed tools from any directory.\n\n* **What it does**: Verifies that the directory where `pip` installs command-line scripts is included in your system's `PATH` environment variable.\n* **How it works**: It uses Python's `sysconfig.get_path('scripts')` to find the correct local scripts directory for your environment and then checks if that directory is present in the `os.environ['PATH']` variable.\n* **Why it matters**: If this path is missing, you might get a \"command not found\" error when trying to run `genesys` after installing it. The doctor will provide the exact `export` command needed to fix this, both for the current session and permanently by adding it to your `.bashrc` or `.zshrc` file.\n\n***\n\n### 2. ROS 2 Environment\n\nThis check verifies that a ROS 2 distribution has been sourced.\n\n* **What it does**: Checks if the `ROS_DISTRO` environment variable is set and if the corresponding ROS 2 `setup.bash` script can be found.\n* **Why it matters**: If you haven't sourced a ROS 2 distribution, most `ros2` and `genesys` commands will fail because they can't find the core ROS 2 packages.\n\n***\n\n### 3. Missing System Dependencies\n\nThis check finds and installs missing system dependencies for the packages in your workspace.\n\n* **What it does**: If run from within a workspace (i.e., a `src` directory is present), it will run `rosdep` to check for any missing system dependencies (e.g., `libopencv-dev`) required by the packages in `src/`.\n* **How it works**: It executes the following command:\n  ```bash\n  rosdep install --from-paths src -y --ignore-src\n  ```\n  * `--from-paths src`: Tells `rosdep` to look at the `package.xml` files of all packages inside the `src` directory.\n  * `-y`: Automatically answers \"yes\" to all prompts from the system's package manager (e.g., `apt-get`), installing dependencies non-interactively.\n  * `--ignore-src`: Prevents `rosdep` from trying to resolve the packages in your `src` directory as system packages, which is the correct behavior.\n* **Why it matters**: This ensures that when you run `genesys build`, the compilation won't fail due to missing system libraries that your ROS 2 packages depend on.\n",
    "_searchMeta": {
      "cleanContent": "cli command: genesys doctor the genesys doctor command is a diagnostic tool that checks your local environment for common configuration problems that could prevent genesys or ros 2 from working correctly it s a good first step for troubleshooting your development environment usage checks performed the doctor runs the following checks in order path configuration this check ensures that you can run genesys and other python-installed tools from any directory what it does: verifies that the directory where pip installs command-line scripts is included in your system s path environment variable how it works: it uses python s sysconfig get_path scripts to find the correct local scripts directory for your environment and then checks if that directory is present in the os environ path variable why it matters: if this path is missing you might get a command not found error when trying to run genesys after installing it the doctor will provide the exact export command needed to fix this both for the current session and permanently by adding it to your bashrc or zshrc file ros 2 environment this check verifies that a ros 2 distribution has been sourced what it does: checks if the ros_distro environment variable is set and if the corresponding ros 2 setup bash script can be found why it matters: if you haven t sourced a ros 2 distribution most ros2 and genesys commands will fail because they can t find the core ros 2 packages missing system dependencies this check finds and installs missing system dependencies for the packages in your workspace what it does: if run from within a workspace i e a src directory is present it will run rosdep to check for any missing system dependencies e g libopencv-dev required by the packages in src how it works: it executes the following command: --from-paths src: tells rosdep to look at the package xml files of all packages inside the src directory -y: automatically answers yes to all prompts from the system s package manager e g apt-get installing dependencies non-interactively --ignore-src: prevents rosdep from trying to resolve the packages in your src directory as system packages which is the correct behavior why it matters: this ensures that when you run genesys build the compilation won t fail due to missing system libraries that your ros 2 packages depend on",
      "headings": [
        "Usage",
        "Checks Performed"
      ],
      "keywords": [
        "Usage",
        "Checks Performed",
        "What it does",
        "How it works",
        "Why it matters",
        "genesys doctor",
        "bash\ngenesys doctor",
        "## Checks Performed\n\nThe doctor runs the following checks in order.\n\n***\n\n### 1.",
        "Configuration\n\nThis check ensures that you can run",
        "and other Python-installed tools from any directory.\n\n* **What it does**: Verifies that the directory where",
        "installs command-line scripts is included in your system's",
        "environment variable.\n* **How it works**: It uses Python's",
        "to find the correct local scripts directory for your environment and then checks if that directory is present in the",
        "variable.\n* **Why it matters**: If this path is missing, you might get a \"command not found\" error when trying to run",
        "after installing it. The doctor will provide the exact",
        "command needed to fix this, both for the current session and permanently by adding it to your",
        "or",
        "file.\n\n***\n\n### 2. ROS 2 Environment\n\nThis check verifies that a ROS 2 distribution has been sourced.\n\n* **What it does**: Checks if the",
        "environment variable is set and if the corresponding ROS 2",
        "script can be found.\n* **Why it matters**: If you haven't sourced a ROS 2 distribution, most",
        "and",
        "commands will fail because they can't find the core ROS 2 packages.\n\n***\n\n### 3. Missing System Dependencies\n\nThis check finds and installs missing system dependencies for the packages in your workspace.\n\n* **What it does**: If run from within a workspace (i.e., a",
        "directory is present), it will run",
        "to check for any missing system dependencies (e.g.,",
        ") required by the packages in",
        ".\n* **How it works**: It executes the following command:",
        "bash\n  rosdep install --from-paths src -y --ignore-src",
        "*",
        ": Tells",
        "to look at the",
        "files of all packages inside the",
        "directory.\n  *",
        ": Automatically answers \"yes\" to all prompts from the system's package manager (e.g.,",
        "), installing dependencies non-interactively.\n  *",
        ": Prevents",
        "from trying to resolve the packages in your",
        "directory as system packages, which is the correct behavior.\n* **Why it matters**: This ensures that when you run"
      ]
    }
  },
  {
    "slug": "/genesys-cli/launch",
    "title": "Launch Command",
    "description": "",
    "content": "# CLI Command: `genesys launch`\n\nThe `genesys launch` command is a powerful wrapper for `ros2 launch` that adds convenience features for launching nodes and entire systems within a Genesys workspace.\n\n## How It Works\n\nBefore running any launch command, `genesys launch` performs two key actions:\n\n1. **Validates Workspace**: It checks for the existence of an `install/` directory to ensure the workspace has been built with a command like `genesys build`.\n2. **Sources Environment**: It automatically sources the `install/setup.bash` (or equivalent) file in a sub-shell. This means you don't have to manually source the workspace in your current terminal session before launching something. The command that gets run is effectively `source install/setup.bash && ros2 launch ...`.\n\n## Usage: Launching a Specific Target\n\nThis is the most common way to launch a single launch file.\n\n```bash\ngenesys launch <target> [launch_arguments]\n```\n\n### Target Formats\n\nThe `<target>` argument can be specified in two ways:\n\n1. **Full Target (`<package>:<launch_file>`)**: This is the most explicit format.\n   ```bash\n   genesys launch my_package:main.launch.py\n   ```\n\n2. **Shorthand (`<package>`)**: If you only provide a package name, it defaults to launching a file named `<package>_launch.py`. This convention works perfectly with the launch files generated by `genesys make node`.\n   ```bash\n   # This command...\r\n   genesys launch my_package\r\n\r\n   # ...is a shortcut for:\r\n   genesys launch my_package:my_package_launch.py\n   ```\n\n### Passing Launch Arguments\n\nAny arguments placed after the target are passed directly to `ros2 launch`.\n\n**Example:**\n\n```bash\ngenesys launch my_package log_level:=debug use_sim_time:=true\n```\n\n***\n\n## Usage: Launching an Entire System\n\nThe `--all` flag is a key feature for bringing up a complete, multi-package system with a single command.\n\n```bash\ngenesys launch --all\n```\n\n### How `--all` Works\n\n1. **Discovery**: It searches every package inside your `src/` directory for a file named exactly `default.launch.py`. The `genesys make` command automatically creates this file for you when you add a node.\n2. **Dynamic Generation**: It dynamically generates a **temporary master launch file**. This file contains a `launch.actions.IncludeLaunchDescription` action for every `default.launch.py` it discovered.\n3. **Execution**: It runs `ros2 launch` on this temporary, in-memory master file, which in turn launches all the individual `default.launch.py` files.\n\nThis mechanism allows each package to define its own default entry point, and `genesys launch --all` acts as the conductor to bring up the entire orchestra at once.\n",
    "_searchMeta": {
      "cleanContent": "cli command: genesys launch the genesys launch command is a powerful wrapper for ros2 launch that adds convenience features for launching nodes and entire systems within a genesys workspace how it works before running any launch command genesys launch performs two key actions: validates workspace: it checks for the existence of an install directory to ensure the workspace has been built with a command like genesys build sources environment: it automatically sources the install setup bash or equivalent file in a sub-shell this means you don t have to manually source the workspace in your current terminal session before launching something the command that gets run is effectively source install setup bash ros2 launch usage: launching a specific target this is the most common way to launch a single launch file target formats the target argument can be specified in two ways: full target package : launch_file : this is the most explicit format shorthand package : if you only provide a package name it defaults to launching a file named package _launch py this convention works perfectly with the launch files generated by genesys make node passing launch arguments any arguments placed after the target are passed directly to ros2 launch example: usage: launching an entire system the --all flag is a key feature for bringing up a complete multi-package system with a single command how --all works discovery: it searches every package inside your src directory for a file named exactly default launch py the genesys make command automatically creates this file for you when you add a node dynamic generation: it dynamically generates a temporary master launch file this file contains a launch actions includelaunchdescription action for every default launch py it discovered execution: it runs ros2 launch on this temporary in-memory master file which in turn launches all the individual default launch py files this mechanism allows each package to define its own default entry point and genesys launch --all acts as the conductor to bring up the entire orchestra at once",
      "headings": [
        "How It Works",
        "Usage: Launching a Specific Target",
        "Usage: Launching an Entire System"
      ],
      "keywords": [
        "How It Works",
        "Usage: Launching a Specific Target",
        "Usage: Launching an Entire System",
        "Validates Workspace",
        "Sources Environment",
        "Full Target (`<package>:<launch_file>`)",
        "Shorthand (`<package>`)",
        "Example:",
        "## Usage: Launching an Entire System\n\nThe `--all` flag is a key feature for bringing up a complete, multi-package system with a single command.\n\n```bash\ngenesys launch --all\n```\n\n### How `--all` Works\n\n1.",
        ": It searches every package inside your `src/` directory for a file named exactly `default.launch.py`. The `genesys make` command automatically creates this file for you when you add a node.\n2.",
        ": It dynamically generates a",
        ". This file contains a `launch.actions.IncludeLaunchDescription` action for every `default.launch.py` it discovered.\n3.",
        "genesys launch",
        "ros2 launch",
        "install/",
        "genesys build",
        "install/setup.bash",
        "source install/setup.bash && ros2 launch ...",
        "bash\ngenesys launch <target> [launch_arguments]",
        "### Target Formats\n\nThe",
        "argument can be specified in two ways:\n\n1. **Full Target (",
        ")**: This is the most explicit format.",
        "bash\n   genesys launch my_package:main.launch.py",
        "2. **Shorthand (",
        ")**: If you only provide a package name, it defaults to launching a file named",
        ". This convention works perfectly with the launch files generated by",
        ".",
        "bash\n   # This command...\r\n   genesys launch my_package\r\n\r\n   # ...is a shortcut for:\r\n   genesys launch my_package:my_package_launch.py",
        "### Passing Launch Arguments\n\nAny arguments placed after the target are passed directly to",
        ".\n\n**Example:**",
        "bash\ngenesys launch my_package log_level:=debug use_sim_time:=true",
        "***\n\n## Usage: Launching an Entire System\n\nThe",
        "flag is a key feature for bringing up a complete, multi-package system with a single command.",
        "bash\ngenesys launch --all",
        "### How",
        "Works\n\n1. **Discovery**: It searches every package inside your",
        "directory for a file named exactly",
        ". The",
        "command automatically creates this file for you when you add a node.\n2. **Dynamic Generation**: It dynamically generates a **temporary master launch file**. This file contains a",
        "action for every",
        "it discovered.\n3. **Execution**: It runs",
        "on this temporary, in-memory master file, which in turn launches all the individual",
        "files.\n\nThis mechanism allows each package to define its own default entry point, and"
      ]
    }
  },
  {
    "slug": "/genesys-cli/make",
    "title": "Make Command",
    "description": "",
    "content": "# CLI Command: `genesys make`\n\nThe `genesys make` command is a powerful scaffolding tool used to create and modify ROS 2 packages, nodes, and components. It automates the tedious process of creating files and editing build configurations.\n\nThis guide provides a detailed breakdown of what each `make` command does behind the scenes.\n\n***\n\n## `genesys make pkg`\n\nCreates a new ROS 2 package in the `src/` directory.\n\n### Usage\n\n```bash\ngenesys make pkg <package_name> [options]\n```\n\n* **`<package_name>`**: The name of the package to create.\n\n### Options\n\n* **`--dependencies <dep1> <dep2>...`**: A list of ROS 2 package dependencies.\n* **`--with-node`**: Automatically create an initial node inside the new package.\n\n### How It Works\n\n1. **Language Choice**: The command interactively prompts you to choose a language (`Python` or `C++`).\n2. **Package Creation**: It runs `ros2 pkg create` with the correct build type (`ament_python` or `ament_cmake`).\n3. **Dependencies**: If dependencies are provided, they are passed to the `ros2 pkg create` command, which adds them to `package.xml`.\n4. **C++ Template**: For C++ packages, it overwrites the default `CMakeLists.txt` with a custom Genesys template that includes helper comments and insertion points for future scaffolding commands.\n\n***\n\n## `genesys make node`\n\nCreates a new ROS 2 node file and registers it in an existing package.\n\n### Usage\n\n```bash\ngenesys make node <node_name> --pkg <package_name> [options]\n```\n\n* **`<node_name>`**: The name for the new node (e.g., `image_processor`).\n* **`--pkg <package_name>`**: The existing package to add the node to.\n* **`--component`**: A flag to create a component instead. This is a shortcut for `genesys make component`.\n\n### How It Works (Python)\n\n1. **Node Type**: Prompts you to select a node type (Publisher, Subscriber, etc.).\n2. **File Creation**: Creates a Python file (e.g., `src/my_pkg/my_pkg/my_node.py`) based on a template for the selected node type.\n3. **`setup.py` Modification**: Automatically adds the node's entry point to `src/my_pkg/setup.py`. This makes the node an executable that ROS 2 can find.\n   ```python\n   # In setup.py\r\n   'console_scripts': [\r\n       'my_node = my_pkg.my_node:main', # This line is added\r\n   ],\n   ```\n4. **Launch File**:\n   * Creates a `src/my_pkg/launch/my_pkg_launch.py` file if one doesn't exist.\n   * Adds the new node to this launch file.\n   * Adds an install rule to `setup.py` to ensure the launch directory is installed.\n     ```python\n     # In setup.py data_files\r\n     (os.path.join('share', package_name, 'launch'), glob(os.path.join('launch', '*launch.py')))\n     ```\n\n### How It Works (C++)\n\n1. **Node Type**: Prompts you to select a node type.\n2. **File Creation**: Creates a header (`.hpp`) and source (`.cpp`) file in `src/my_pkg/include/my_pkg/` and `src/my_pkg/src/` respectively, based on templates. The C++ macros are also available as a seperate package in the src of your general workspace, the templates generated for the publisher and subscriber nodes, make use of the macros, however, they can be altered to suit your coding choices!.\n3. **`CMakeLists.txt` Modification**: Adds a new executable target as well as the genesys macros dependencies.\n   ```cmake\n   # In CMakeLists.txt\r\n   add_executable(my_node src/my_node.cpp)\r\n   ament_target_dependencies(my_node rclcpp std_msgs) # Dependencies added here\r\n   install(TARGETS my_node DESTINATION lib/${PROJECT_NAME})\n   ```\n4. **`package.xml` Modification**: Adds any necessary `<depend>` tags for the node's dependencies as well as the macros.\n5. **Launch File**: The same launch file generation and installation logic as the Python version is applied, but the install rule is added to `CMakeLists.txt`.\n   ```cmake\n   # In CMakeLists.txt\r\n   install(\r\n     DIRECTORY launch\r\n     DESTINATION share/${PROJECT_NAME}\r\n   )\n   ```\n\n***\n\n## `genesys make component`\n\nCreates a new ROS 2 component (a composable node) and registers it.\n\n### Usage\n\n```bash\ngenesys make component <component_name> --pkg <package_name>\n```\n\n* **`<component_name>`**: The name for the new component.\n* **`--pkg <package_name>`**: The existing package to add the component to.\n\n### How It Works (C++)\n\nThis is the most complex scaffolding operation.\n\n1. **File Creation**: Creates `.hpp` and `.cpp` files for the component class.\n2. **Component Registration**: Creates or updates a `src/register_components.cpp` file. This file uses the `RCLCPP_COMPONENTS_REGISTER_NODE` macro to register your component with `pluginlib`, which is the underlying mechanism for C++ components.\n   ```cpp\n   // In src/register_components.cpp\r\n   #include \"my_pkg/my_component.hpp\"\r\n   RCLCPP_COMPONENTS_REGISTER_NODE(my_pkg::MyComponent) // This line is added\n   ```\n3. **`CMakeLists.txt` Modification**:\n   * If this is the first component in the package, it adds a large block to create a **shared library** named `${PROJECT_NAME}_components`. All subsequent components in the package are added to this same library.\n   * It links the component source files and `register_components.cpp` to this library.\n   * It uses `rclcpp_components_register_nodes` to export the component plugins.\n4. **Plugin XML**: Creates or updates `resource/pkg_name_plugin.xml`. This XML file is what `pluginlib` uses at runtime to find and load your component.\n   ```xml\n   <!-- In resource/pkg_name_plugin.xml -->\r\n   <class type=\"my_pkg::MyComponent\" base_class_type=\"rclcpp::Node\">\r\n     <description>...</description>\r\n   </class>\n   ```\n5. **`package.xml` Modification**:\n   * Adds dependencies like `rclcpp_components` and `pluginlib`.\n   * Adds an `<export>` tag to point to the plugin XML file.\n\n***\n\n## `genesys make launch`\n\nCreates a new launch file.\n\n### Usage\n\n```bash\ngenesys make launch --pkg <package_name> --name <launch_name>\n```\n\n* **`--pkg <package_name>`**: The package to create the launch file in.\n* **`--name <launch_name>`**: The name of the launch file (defaults to `mixed_launch`).\n\n### Description\n\nBy default, this creates a `mixed_launch.py` file. A mixed launch file is pre-configured with a `ComposableNodeContainer`, which allows you to efficiently run multiple components in a single process. It also has a section for regular, standalone nodes. This is the preferred launch file type when working with components.\n\n***\n\n## `genesys make interface`\n\nThis command is a placeholder and is **not yet implemented**. It will print manual instructions for how to create custom message, service, or action files.\n",
    "_searchMeta": {
      "cleanContent": "cli command: genesys make the genesys make command is a powerful scaffolding tool used to create and modify ros 2 packages nodes and components it automates the tedious process of creating files and editing build configurations this guide provides a detailed breakdown of what each make command does behind the scenes genesys make pkg creates a new ros 2 package in the src directory usage package_name : the name of the package to create options --dependencies dep1 dep2 : a list of ros 2 package dependencies --with-node: automatically create an initial node inside the new package how it works language choice: the command interactively prompts you to choose a language python or c package creation: it runs ros2 pkg create with the correct build type amentpython or amentcmake dependencies: if dependencies are provided they are passed to the ros2 pkg create command which adds them to package xml c template: for c packages it overwrites the default cmakelists txt with a custom genesys template that includes helper comments and insertion points for future scaffolding commands genesys make node creates a new ros 2 node file and registers it in an existing package usage nodename : the name for the new node e g imageprocessor --pkg package_name : the existing package to add the node to --component: a flag to create a component instead this is a shortcut for genesys make component how it works python node type: prompts you to select a node type publisher subscriber etc file creation: creates a python file e g src mypkg mypkg my_node py based on a template for the selected node type setup py modification: automatically adds the node s entry point to src my_pkg setup py this makes the node an executable that ros 2 can find launch file: creates a src mypkg launch mypkg_launch py file if one doesn t exist adds the new node to this launch file adds an install rule to setup py to ensure the launch directory is installed how it works c node type: prompts you to select a node type file creation: creates a header hpp and source cpp file in src mypkg include mypkg and src my_pkg src respectively based on templates the c macros are also available as a seperate package in the src of your general workspace the templates generated for the publisher and subscriber nodes make use of the macros however they can be altered to suit your coding choices cmakelists txt modification: adds a new executable target as well as the genesys macros dependencies package xml modification: adds any necessary depend tags for the node s dependencies as well as the macros launch file: the same launch file generation and installation logic as the python version is applied but the install rule is added to cmakelists txt genesys make component creates a new ros 2 component a composable node and registers it usage component_name : the name for the new component --pkg package_name : the existing package to add the component to how it works c this is the most complex scaffolding operation file creation: creates hpp and cpp files for the component class component registration: creates or updates a src registercomponents cpp file this file uses the rclcppcomponentsregisternode macro to register your component with pluginlib which is the underlying mechanism for c components cmakelists txt modification: if this is the first component in the package it adds a large block to create a shared library named projectname components all subsequent components in the package are added to this same library it links the component source files and register_components cpp to this library it uses rclcppcomponentsregister_nodes to export the component plugins plugin xml: creates or updates resource pkgnameplugin xml this xml file is what pluginlib uses at runtime to find and load your component package xml modification: adds dependencies like rclcpp_components and pluginlib adds an export tag to point to the plugin xml file genesys make launch creates a new launch file usage --pkg package_name : the package to create the launch file in --name launchname : the name of the launch file defaults to mixedlaunch description by default this creates a mixed_launch py file a mixed launch file is pre-configured with a composablenodecontainer which allows you to efficiently run multiple components in a single process it also has a section for regular standalone nodes this is the preferred launch file type when working with components genesys make interface this command is a placeholder and is not yet implemented it will print manual instructions for how to create custom message service or action files",
      "headings": [
        "`genesys make pkg`",
        "`genesys make node`",
        "`genesys make component`",
        "`genesys make launch`",
        "`genesys make interface`"
      ],
      "keywords": [
        "`genesys make pkg`",
        "`genesys make node`",
        "`genesys make component`",
        "`genesys make launch`",
        "`genesys make interface`",
        "`<package_name>`",
        "`--dependencies <dep1> <dep2>...`",
        "`--with-node`",
        "Language Choice",
        "Package Creation",
        "Dependencies",
        "C++ Template",
        "`<node_name>`",
        "`--pkg <package_name>`",
        "`--component`",
        "Node Type",
        "File Creation",
        "`setup.py` Modification",
        "Launch File",
        "`CMakeLists.txt` Modification",
        "`package.xml` Modification",
        "`<component_name>`",
        "Component Registration",
        "shared library",
        "Plugin XML",
        "`--name <launch_name>`",
        "## `genesys make interface`\n\nThis command is a placeholder and is",
        "genesys make",
        "make",
        "genesys make pkg",
        "src/",
        "bash\ngenesys make pkg <package_name> [options]",
        "* **",
        "**: The name of the package to create.\n\n### Options\n\n* **",
        "**: A list of ROS 2 package dependencies.\n* **",
        "**: Automatically create an initial node inside the new package.\n\n### How It Works\n\n1. **Language Choice**: The command interactively prompts you to choose a language (",
        "or",
        ").\n2. **Package Creation**: It runs",
        "with the correct build type (",
        ").\n3. **Dependencies**: If dependencies are provided, they are passed to the",
        "command, which adds them to",
        ".\n4. **C++ Template**: For C++ packages, it overwrites the default",
        "with a custom Genesys template that includes helper comments and insertion points for future scaffolding commands.\n\n***\n\n##",
        "Creates a new ROS 2 node file and registers it in an existing package.\n\n### Usage",
        "bash\ngenesys make node <node_name> --pkg <package_name> [options]",
        "**: The name for the new node (e.g.,",
        ").\n* **",
        "**: The existing package to add the node to.\n* **",
        "**: A flag to create a component instead. This is a shortcut for",
        ".\n\n### How It Works (Python)\n\n1. **Node Type**: Prompts you to select a node type (Publisher, Subscriber, etc.).\n2. **File Creation**: Creates a Python file (e.g.,",
        ") based on a template for the selected node type.\n3. **",
        "Modification**: Automatically adds the node's entry point to",
        ". This makes the node an executable that ROS 2 can find.",
        "python\n   # In setup.py\r\n   'console_scripts': [\r\n       'my_node = my_pkg.my_node:main', # This line is added\r\n   ],",
        "4. **Launch File**:\n   * Creates a",
        "file if one doesn't exist.\n   * Adds the new node to this launch file.\n   * Adds an install rule to",
        "to ensure the launch directory is installed.",
        "python\n     # In setup.py data_files\r\n     (os.path.join('share', package_name, 'launch'), glob(os.path.join('launch', '*launch.py')))",
        "### How It Works (C++)\n\n1. **Node Type**: Prompts you to select a node type.\n2. **File Creation**: Creates a header (",
        ") and source (",
        ") file in",
        "and",
        "respectively, based on templates. The C++ macros are also available as a seperate package in the src of your general workspace, the templates generated for the publisher and subscriber nodes, make use of the macros, however, they can be altered to suit your coding choices!.\n3. **",
        "Modification**: Adds a new executable target as well as the genesys macros dependencies.",
        "cmake\n   # In CMakeLists.txt\r\n   add_executable(my_node src/my_node.cpp)\r\n   ament_target_dependencies(my_node rclcpp std_msgs) # Dependencies added here\r\n   install(TARGETS my_node DESTINATION lib/${PROJECT_NAME})",
        "4. **",
        "Modification**: Adds any necessary",
        "tags for the node's dependencies as well as the macros.\n5. **Launch File**: The same launch file generation and installation logic as the Python version is applied, but the install rule is added to",
        ".",
        "cmake\n   # In CMakeLists.txt\r\n   install(\r\n     DIRECTORY launch\r\n     DESTINATION share/${PROJECT_NAME}\r\n   )",
        "***\n\n##",
        "Creates a new ROS 2 component (a composable node) and registers it.\n\n### Usage",
        "bash\ngenesys make component <component_name> --pkg <package_name>",
        "**: The name for the new component.\n* **",
        "**: The existing package to add the component to.\n\n### How It Works (C++)\n\nThis is the most complex scaffolding operation.\n\n1. **File Creation**: Creates",
        "files for the component class.\n2. **Component Registration**: Creates or updates a",
        "file. This file uses the",
        "macro to register your component with",
        ", which is the underlying mechanism for C++ components.",
        "cpp\n   // In src/register_components.cpp\r\n   #include \"my_pkg/my_component.hpp\"\r\n   RCLCPP_COMPONENTS_REGISTER_NODE(my_pkg::MyComponent) // This line is added",
        "3. **",
        "Modification**:\n   * If this is the first component in the package, it adds a large block to create a **shared library** named",
        ". All subsequent components in the package are added to this same library.\n   * It links the component source files and",
        "to this library.\n   * It uses",
        "to export the component plugins.\n4. **Plugin XML**: Creates or updates",
        ". This XML file is what",
        "uses at runtime to find and load your component.",
        "xml\n   <!-- In resource/pkg_name_plugin.xml -->\r\n   <class type=\"my_pkg::MyComponent\" base_class_type=\"rclcpp::Node\">\r\n     <description>...</description>\r\n   </class>",
        "5. **",
        "Modification**:\n   * Adds dependencies like",
        ".\n   * Adds an",
        "tag to point to the plugin XML file.\n\n***\n\n##",
        "Creates a new launch file.\n\n### Usage",
        "bash\ngenesys make launch --pkg <package_name> --name <launch_name>",
        "**: The package to create the launch file in.\n* **",
        "**: The name of the launch file (defaults to",
        ").\n\n### Description\n\nBy default, this creates a",
        "file. A mixed launch file is pre-configured with a",
        ", which allows you to efficiently run multiple components in a single process. It also has a section for regular, standalone nodes. This is the preferred launch file type when working with components.\n\n***\n\n##"
      ]
    }
  },
  {
    "slug": "/genesys-cli/new",
    "title": "New Command",
    "description": "",
    "content": "# CLI Command: `genesys new`\n\nThe `genesys new` command creates a new, structured ROS 2 workspace with the standard Genesys directory layout, it also provides a package which contains the c++ macros for c++ nodes. It is contained in the genesys\\_macro directory.\n\n## Usage\n\n```bash\ngenesys new <project_name>\n```\n\n* **`<project_name>`**: The name of the workspace directory to be created.\n\n## Description\n\nThis command sets up a clean workspace, ready for you to start creating packages. It creates the following directory structure:\n\n```\n<project_name>/\r\n‚îú‚îÄ‚îÄ src/         # For your ROS 2 packages\r\n‚îú‚îÄ‚îÄ launch/      # For top-level launch files\r\n‚îú‚îÄ‚îÄ config/      # For global configuration files\r\n‚îú‚îÄ‚îÄ sim/         # For Gazebo simulation packages\r\n‚îú‚îÄ‚îÄ tests/       # For workspace-level integration tests\r\n‚îú‚îÄ‚îÄ scripts/     # For utility scripts\r\n‚îî‚îÄ‚îÄ tools/       # For miscellaneous tools\n```\n\n### Example\n\n```bash\ngenesys new my_robot_project\n```\n\nThis will create a directory named `my_robot_project` with the structure shown above.\n\nAfter running the command, you can navigate into the new directory and begin adding packages:\n\n```bash\ncd my_robot_project\r\ngenesys make pkg my_first_package\n```\n",
    "_searchMeta": {
      "cleanContent": "cli command: genesys new the genesys new command creates a new structured ros 2 workspace with the standard genesys directory layout it also provides a package which contains the c macros for c nodes it is contained in the genesys _macro directory usage project_name : the name of the workspace directory to be created description this command sets up a clean workspace ready for you to start creating packages it creates the following directory structure: example this will create a directory named myrobotproject with the structure shown above after running the command you can navigate into the new directory and begin adding packages:",
      "headings": [
        "Usage",
        "Description"
      ],
      "keywords": [
        "Usage",
        "Description",
        "`<project_name>`",
        "genesys new",
        "bash\ngenesys new <project_name>",
        "* **",
        "**: The name of the workspace directory to be created.\n\n## Description\n\nThis command sets up a clean workspace, ready for you to start creating packages. It creates the following directory structure:",
        "<project_name>/\r\n‚îú‚îÄ‚îÄ src/         # For your ROS 2 packages\r\n‚îú‚îÄ‚îÄ launch/      # For top-level launch files\r\n‚îú‚îÄ‚îÄ config/      # For global configuration files\r\n‚îú‚îÄ‚îÄ sim/         # For Gazebo simulation packages\r\n‚îú‚îÄ‚îÄ tests/       # For workspace-level integration tests\r\n‚îú‚îÄ‚îÄ scripts/     # For utility scripts\r\n‚îî‚îÄ‚îÄ tools/       # For miscellaneous tools",
        "### Example",
        "bash\ngenesys new my_robot_project",
        "This will create a directory named",
        "with the structure shown above.\n\nAfter running the command, you can navigate into the new directory and begin adding packages:",
        "bash\ncd my_robot_project\r\ngenesys make pkg my_first_package"
      ]
    }
  },
  {
    "slug": "/genesys-cli/pipeline",
    "title": "Pipeline Tooling",
    "description": "",
    "content": "# CLI Command: `genesys pipeline`\n\nThe `genesys pipeline` command group provides tools for managing and running declarative component graphs defined in YAML files. This allows you to define an entire multi-node system in one place.\n\nSee the main [Pipelines Documentation](./pipeline.md) for details on the YAML format.\n\n***\n\n## `genesys pipeline create`\n\nCreates a new boilerplate pipeline YAML file.\n\n### Usage\n\n```bash\ngenesys pipeline create <pipeline_name>\n```\n\n* **`<pipeline_name>`**: The desired name for your pipeline.\n\n### Description\n\nThis command creates a new file named `<pipeline_name>.yaml` in the current directory with a basic structure, ready for you to add nodes.\n\n**Example:**\n\n```bash\ngenesys pipeline create vision_system\n```\n\nThis creates `vision_system.yaml` with the following content:\n\n```yaml\npipeline:\r\n  name: vision_system\r\n  nodes: []\n```\n\n***\n\n## `genesys pipeline run`\n\nParses a pipeline YAML file and launches the defined graph of nodes and components.\n\n### Usage\n\n```bash\ngenesys pipeline run <path_to_pipeline.yaml>\n```\n\n### How It Works\n\nThe `run` command provides a more direct way to launch a system compared to `genesys launch`.\n\n1. **Parse**: It reads and validates the pipeline YAML file.\n2. **Generate**: It converts the YAML definition into a ROS 2 `LaunchDescription` object **in memory**.\n3. **Execute**: Instead of calling `ros2 launch` as a subprocess, it uses the `launch.LaunchService` API from ROS 2 to run the generated launch description directly within the same process. This gives it more control, which is essential for the `watch` feature.\n\n**Example:**\n\n```bash\ngenesys pipeline run vision_system.yaml\n```\n\n***\n\n## `genesys pipeline watch`\n\nRuns a pipeline and automatically reloads it when the YAML file is changed. This provides a \"hot-reload\" capability for your system architecture.\n\n### Usage\n\n```bash\ngenesys pipeline watch <path_to_pipeline.yaml>\n```\n\n### How It Works\n\nThis is a powerful command for rapid development and iteration.\n\n1. **Initial Launch**: It starts by calling `genesys pipeline run` to launch the initial version of your pipeline.\n2. **File Monitoring**: It then uses the `watchdog` library to monitor your pipeline YAML file for any modifications.\n3. **Hot Reload**: When you save a change to the file, `watchdog` detects the event. The `watch` command then:\r\n   a.  Gracefully **shuts down** the currently running `LaunchService`.\r\n   b.  **Re-runs** the `run` command to parse the modified YAML and start a new `LaunchService` with the updated configuration.\n\nThis allows you to add/remove nodes, change parameters, or update topic remappings and see the changes take effect live within seconds, just by saving the file.\n\n**Example:**\n\n```bash\ngenesys pipeline watch vision_system.yaml\n```\n\nNow, every time you edit and save `vision_system.yaml`, the changes will be applied automatically.\n",
    "_searchMeta": {
      "cleanContent": "cli command: genesys pipeline the genesys pipeline command group provides tools for managing and running declarative component graphs defined in yaml files this allows you to define an entire multi-node system in one place see the main pipelines documentation for details on the yaml format genesys pipeline create creates a new boilerplate pipeline yaml file usage pipeline_name : the desired name for your pipeline description this command creates a new file named pipeline_name yaml in the current directory with a basic structure ready for you to add nodes example: this creates vision_system yaml with the following content: genesys pipeline run parses a pipeline yaml file and launches the defined graph of nodes and components usage how it works the run command provides a more direct way to launch a system compared to genesys launch parse: it reads and validates the pipeline yaml file generate: it converts the yaml definition into a ros 2 launchdescription object in memory execute: instead of calling ros2 launch as a subprocess it uses the launch launchservice api from ros 2 to run the generated launch description directly within the same process this gives it more control which is essential for the watch feature example: genesys pipeline watch runs a pipeline and automatically reloads it when the yaml file is changed this provides a hot-reload capability for your system architecture usage how it works this is a powerful command for rapid development and iteration initial launch: it starts by calling genesys pipeline run to launch the initial version of your pipeline file monitoring: it then uses the watchdog library to monitor your pipeline yaml file for any modifications hot reload: when you save a change to the file watchdog detects the event the watch command then: a gracefully shuts down the currently running launchservice b re-runs the run command to parse the modified yaml and start a new launchservice with the updated configuration this allows you to add remove nodes change parameters or update topic remappings and see the changes take effect live within seconds just by saving the file example: now every time you edit and save vision_system yaml the changes will be applied automatically",
      "headings": [
        "`genesys pipeline create`",
        "`genesys pipeline run`",
        "`genesys pipeline watch`"
      ],
      "keywords": [
        "`genesys pipeline create`",
        "`genesys pipeline run`",
        "`genesys pipeline watch`",
        "`<pipeline_name>`",
        "Example:",
        "## `genesys pipeline run`\n\nParses a pipeline YAML file and launches the defined graph of nodes and components.\n\n### Usage\n\n```bash\ngenesys pipeline run <path_to_pipeline.yaml>\n```\n\n### How It Works\n\nThe `run` command provides a more direct way to launch a system compared to `genesys launch`.\n\n1.",
        ": It reads and validates the pipeline YAML file.\n2.",
        ": It converts the YAML definition into a ROS 2 `LaunchDescription` object",
        ".\n3.",
        ": Instead of calling `ros2 launch` as a subprocess, it uses the `launch.LaunchService` API from ROS 2 to run the generated launch description directly within the same process. This gives it more control, which is essential for the `watch` feature.",
        "```bash\ngenesys pipeline run vision_system.yaml\n```",
        "Initial Launch",
        "File Monitoring",
        "Hot Reload",
        "shuts down",
        "Re-runs",
        "genesys pipeline",
        "genesys pipeline create",
        "bash\ngenesys pipeline create <pipeline_name>",
        "* **",
        "**: The desired name for your pipeline.\n\n### Description\n\nThis command creates a new file named",
        "in the current directory with a basic structure, ready for you to add nodes.\n\n**Example:**",
        "bash\ngenesys pipeline create vision_system",
        "This creates",
        "with the following content:",
        "yaml\npipeline:\r\n  name: vision_system\r\n  nodes: []",
        "***\n\n##",
        "Parses a pipeline YAML file and launches the defined graph of nodes and components.\n\n### Usage",
        "bash\ngenesys pipeline run <path_to_pipeline.yaml>",
        "### How It Works\n\nThe",
        "command provides a more direct way to launch a system compared to",
        ".\n\n1. **Parse**: It reads and validates the pipeline YAML file.\n2. **Generate**: It converts the YAML definition into a ROS 2",
        "object **in memory**.\n3. **Execute**: Instead of calling",
        "as a subprocess, it uses the",
        "API from ROS 2 to run the generated launch description directly within the same process. This gives it more control, which is essential for the",
        "feature.\n\n**Example:**",
        "bash\ngenesys pipeline run vision_system.yaml",
        "Runs a pipeline and automatically reloads it when the YAML file is changed. This provides a \"hot-reload\" capability for your system architecture.\n\n### Usage",
        "bash\ngenesys pipeline watch <path_to_pipeline.yaml>",
        "### How It Works\n\nThis is a powerful command for rapid development and iteration.\n\n1. **Initial Launch**: It starts by calling",
        "to launch the initial version of your pipeline.\n2. **File Monitoring**: It then uses the",
        "library to monitor your pipeline YAML file for any modifications.\n3. **Hot Reload**: When you save a change to the file,",
        "detects the event. The",
        "command then:\r\n   a.  Gracefully **shuts down** the currently running",
        ".\r\n   b.  **Re-runs** the",
        "command to parse the modified YAML and start a new",
        "with the updated configuration.\n\nThis allows you to add/remove nodes, change parameters, or update topic remappings and see the changes take effect live within seconds, just by saving the file.\n\n**Example:**",
        "bash\ngenesys pipeline watch vision_system.yaml",
        "Now, every time you edit and save"
      ]
    }
  },
  {
    "slug": "/genesys-cli/rqt",
    "title": "RQT Tooling",
    "description": "",
    "content": "# CLI Command: `genesys rqt`\n\nThe `genesys rqt` command group provides simple shortcuts for launching common RQT (ROS Qt) GUI tools.\n\n## Usage\n\n```bash\ngenesys rqt <tool_name>\n```\n\n## Available Tools\n\n### `genesys rqt graph`\n\nLaunches the RQT Node Graph plugin.\n\n**Usage:**\n\n```bash\ngenesys rqt graph\n```\n\nThis is one of the most useful debugging tools in ROS 2. It provides a graphical representation of your running system, showing all the active nodes and the topics connecting them.\n\n### `genesys rqt console`\n\nLaunches the RQT Console plugin.\n\n**Usage:**\n\n```bash\ngenesys rqt console\n```\n\nThis tool aggregates log messages from all running nodes into a single, filterable GUI. You can use it to view, sort, and search through log messages by severity, node name, or time. It is often more convenient than looking at the raw console output.\n",
    "_searchMeta": {
      "cleanContent": "cli command: genesys rqt the genesys rqt command group provides simple shortcuts for launching common rqt ros qt gui tools usage available tools genesys rqt graph launches the rqt node graph plugin usage: this is one of the most useful debugging tools in ros 2 it provides a graphical representation of your running system showing all the active nodes and the topics connecting them genesys rqt console launches the rqt console plugin usage: this tool aggregates log messages from all running nodes into a single filterable gui you can use it to view sort and search through log messages by severity node name or time it is often more convenient than looking at the raw console output",
      "headings": [
        "Usage",
        "Available Tools"
      ],
      "keywords": [
        "Usage",
        "Available Tools",
        "Usage:",
        "genesys rqt",
        "bash\ngenesys rqt <tool_name>",
        "## Available Tools\n\n###",
        "Launches the RQT Node Graph plugin.\n\n**Usage:**",
        "bash\ngenesys rqt graph",
        "This is one of the most useful debugging tools in ROS 2. It provides a graphical representation of your running system, showing all the active nodes and the topics connecting them.\n\n###",
        "Launches the RQT Console plugin.\n\n**Usage:**",
        "bash\ngenesys rqt console"
      ]
    }
  },
  {
    "slug": "/genesys-cli/run",
    "title": "Run Command",
    "description": "",
    "content": "# CLI Command: `genesys run`\n\nThe `genesys run` command executes a ROS 2 node by its name, automatically finding which package it belongs to. This is a significant convenience over the standard `ros2 run <package_name> <executable_name>` command.\n\n## Usage\n\n```bash\ngenesys run <node_name> [arguments]\n```\n\n* **`<node_name>`**: The name of the executable for the node you want to run.\n* **`[arguments]`**: Any additional arguments to pass to the node, including ROS arguments like remapping rules.\n\n## How It Works\n\nThe command simplifies running nodes by removing the need to specify the package name. Here's the process:\n\n1. **Workspace Validation**: It first checks for an `install/` directory to ensure the workspace has been built.\n2. **Discover Nodes**: It runs the `ros2 pkg executables` command in a sourced sub-shell. This command returns a list of all packages and the executables they provide.\n3. **Find Package**: It parses the output from the previous step to create a map of every known executable to its parent package. It uses this map to find the package that owns the `<node_name>` you requested.\n4. **Error Handling**: If the node name is not found in any package, it prints an error and a list of all available node executables it discovered, helping you find the correct name.\n5. **Execute**: Once the package is found, it constructs and executes the full `ros2 run <package_name> <node_name>` command, passing along any extra arguments you provided.\n\n## Remapping Arguments\n\nThe `run` command provides a simplified and more intuitive syntax for remapping topics.\n\n* `--remap <old>:=<new>`\n* `--remap=<old>:=<new>`\n\nThe command automatically converts this into the format that `ros2 run` expects. For example:\n\n```bash\n# This command...\r\ngenesys run listener_node --remap /chatter:=/my_chatter_topic\r\n\r\n# ...is automatically converted and run as:\r\nros2 run <pkg> listener_node --ros-args -r /chatter:=/my_chatter_topic\n```\n\n## Example\n\nIf you have a node named `talker_node` in `my_package`, you can run it with:\n\n```bash\ngenesys run talker_node\n```\n\nThe command will discover that `talker_node` belongs to `my_package` and execute `ros2 run my_package talker_node`.\n",
    "_searchMeta": {
      "cleanContent": "cli command: genesys run the genesys run command executes a ros 2 node by its name automatically finding which package it belongs to this is a significant convenience over the standard ros2 run packagename executablename command usage node_name : the name of the executable for the node you want to run arguments : any additional arguments to pass to the node including ros arguments like remapping rules how it works the command simplifies running nodes by removing the need to specify the package name here s the process: workspace validation: it first checks for an install directory to ensure the workspace has been built discover nodes: it runs the ros2 pkg executables command in a sourced sub-shell this command returns a list of all packages and the executables they provide find package: it parses the output from the previous step to create a map of every known executable to its parent package it uses this map to find the package that owns the node_name you requested error handling: if the node name is not found in any package it prints an error and a list of all available node executables it discovered helping you find the correct name execute: once the package is found it constructs and executes the full ros2 run packagename nodename command passing along any extra arguments you provided remapping arguments the run command provides a simplified and more intuitive syntax for remapping topics --remap old : new --remap old : new the command automatically converts this into the format that ros2 run expects for example: example if you have a node named talkernode in mypackage you can run it with: the command will discover that talkernode belongs to mypackage and execute ros2 run mypackage talkernode",
      "headings": [
        "Usage",
        "How It Works",
        "Remapping Arguments",
        "Example"
      ],
      "keywords": [
        "Usage",
        "How It Works",
        "Remapping Arguments",
        "Example",
        "`<node_name>`",
        "`[arguments]`",
        "Workspace Validation",
        "Discover Nodes",
        "Find Package",
        "Error Handling",
        "Execute",
        "genesys run",
        "ros2 run <package_name> <executable_name>",
        "bash\ngenesys run <node_name> [arguments]",
        "* **",
        "**: The name of the executable for the node you want to run.\n* **",
        "**: Any additional arguments to pass to the node, including ROS arguments like remapping rules.\n\n## How It Works\n\nThe command simplifies running nodes by removing the need to specify the package name. Here's the process:\n\n1. **Workspace Validation**: It first checks for an",
        "directory to ensure the workspace has been built.\n2. **Discover Nodes**: It runs the",
        "command in a sourced sub-shell. This command returns a list of all packages and the executables they provide.\n3. **Find Package**: It parses the output from the previous step to create a map of every known executable to its parent package. It uses this map to find the package that owns the",
        "you requested.\n4. **Error Handling**: If the node name is not found in any package, it prints an error and a list of all available node executables it discovered, helping you find the correct name.\n5. **Execute**: Once the package is found, it constructs and executes the full",
        "command, passing along any extra arguments you provided.\n\n## Remapping Arguments\n\nThe",
        "command provides a simplified and more intuitive syntax for remapping topics.\n\n*",
        "*",
        "The command automatically converts this into the format that",
        "expects. For example:",
        "bash\n# This command...\r\ngenesys run listener_node --remap /chatter:=/my_chatter_topic\r\n\r\n# ...is automatically converted and run as:\r\nros2 run <pkg> listener_node --ros-args -r /chatter:=/my_chatter_topic",
        "## Example\n\nIf you have a node named",
        "in",
        ", you can run it with:",
        "bash\ngenesys run talker_node",
        "The command will discover that",
        "belongs to",
        "and execute"
      ]
    }
  },
  {
    "slug": "/genesys-cli/sim",
    "title": "Sim Command",
    "description": "",
    "content": "# CLI Command: `genesys sim`\n\nThe `genesys sim` command group provides tools to create and manage Gazebo simulations within your workspace. It standardizes the process of setting up a simulation environment for a robot, which is often a complex and error-prone task.\n\n***\n\n## `genesys sim create`\n\nCreates a new `*_gazebo` package in the `sim/` directory, fully configured for a specific robot.\n\n### Usage\n\n```bash\ngenesys sim create <package_name> --from-pkg <robot_description_package>\n```\n\n* **`<package_name>`**: The name of the simulation package. By convention, this **must** end in `_gazebo` (e.g., `my_robot_gazebo`).\n* **`--from-pkg <robot_description_package>`**: The name of an existing package that contains the robot's URDF or XACRO files (e.g., `ur_description`).\n\n### How It Works\n\nThis command automates the creation of a complete Gazebo simulation package.\n\n1. **Directory Creation**: It creates a new package inside the `sim/` directory (creating `sim/` if it doesn't exist). This keeps simulation packages separate from your robot's source code in `src/`.\n2. **Dependency Check**: It runs `rosdep check` and `rosdep install` to ensure that necessary simulation dependencies like `gazebo_ros_pkgs` are installed on your system.\n3. **Template Rendering**: It generates a standard set of subdirectories (`launch`, `worlds`, `models`, `config`, `urdf`) and populates them with boilerplate files rendered from internal templates. This includes:\n   * `CMakeLists.txt` and `package.xml`\n   * A main launch file (`<package_name>.launch.py`) to start Gazebo and the robot.\n   * A secondary launch file to spawn the robot model (`spawn_<robot_name>.launch.py`).\n   * A default `controllers.yaml` for a `ros2_control` setup.\n   * `default.world` and `empty.world` files.\n4. **URDF Linking**: To ensure the simulation always uses the most up-to-date robot model, it tries to **symlink** the `urdf` directory from the source package (`--from-pkg`) into the new simulation package. If symlinking fails (e.g., due to permissions), it falls back to copying the directory.\n\n**Example:**\n\n```bash\ngenesys sim create my_robot_gazebo --from-pkg my_robot_description\n```\n\n***\n\n## `genesys sim run`\n\nLaunches a Gazebo simulation from one of the `*_gazebo` packages.\n\n### Usage\n\n```bash\ngenesys sim run <package_name> [options]\n```\n\n* **`<package_name>`**: The name of the simulation package to run (e.g., `my_robot_gazebo`). It must be located in the `sim/` directory.\n\n### Options\n\n* **`--world <world_file.world>`**: Specify a world file to load from the package's `worlds/` directory. Defaults to `empty.world`.\n* **`--headless`**: Run Gazebo in headless mode (no GUI). This is useful for running simulations on a server or as part of a CI/CD pipeline.\n\n### How It Works\n\n1. **Workspace Validation**: Checks that the workspace has been built (`install/` exists) and the specified `<package_name>` exists in the `sim/` directory.\n2. **Environment Setup**: It modifies the environment for the launch subprocess. This is the key to making Gazebo find all the necessary files. It sets the following environment variables:\n   * `GAZEBO_MODEL_PATH`: Points to the `models` directory in your sim package.\n   * `GZ_SIM_RESOURCE_PATH`: Points to both the `worlds` and `models` directories.\n   * `GAZEBO_WORLD`: Set to the value of the `--world` option.\n   * `HEADLESS`: Set to `1` if the `--headless` flag is used.\n3. **Execution**: It sources the local workspace and executes the main launch file for the simulation package (`ros2 launch <package_name> <package_name>.launch.py`) using the modified environment.\n\n**Example:**\n\n```bash\n# Run the simulation with a GUI and a specific world\r\ngenesys sim run my_robot_gazebo --world my_world.world\r\n\r\n# Run the simulation without a GUI\r\ngenesys sim run my_robot_gazebo --headless\n```\n",
    "_searchMeta": {
      "cleanContent": "cli command: genesys sim the genesys sim command group provides tools to create and manage gazebo simulations within your workspace it standardizes the process of setting up a simulation environment for a robot which is often a complex and error-prone task genesys sim create creates a new _gazebo package in the sim directory fully configured for a specific robot usage packagename : the name of the simulation package by convention this must end in gazebo e g myrobotgazebo --from-pkg robotdescriptionpackage : the name of an existing package that contains the robot s urdf or xacro files e g ur_description how it works this command automates the creation of a complete gazebo simulation package directory creation: it creates a new package inside the sim directory creating sim if it doesn t exist this keeps simulation packages separate from your robot s source code in src dependency check: it runs rosdep check and rosdep install to ensure that necessary simulation dependencies like gazeborospkgs are installed on your system template rendering: it generates a standard set of subdirectories launch worlds models config urdf and populates them with boilerplate files rendered from internal templates this includes: cmakelists txt and package xml a main launch file package_name launch py to start gazebo and the robot a secondary launch file to spawn the robot model spawn robotname launch py a default controllers yaml for a ros2_control setup default world and empty world files urdf linking: to ensure the simulation always uses the most up-to-date robot model it tries to symlink the urdf directory from the source package --from-pkg into the new simulation package if symlinking fails e g due to permissions it falls back to copying the directory example: genesys sim run launches a gazebo simulation from one of the _gazebo packages usage packagename : the name of the simulation package to run e g myrobot_gazebo it must be located in the sim directory options --world world_file world : specify a world file to load from the package s worlds directory defaults to empty world --headless: run gazebo in headless mode no gui this is useful for running simulations on a server or as part of a ci cd pipeline how it works workspace validation: checks that the workspace has been built install exists and the specified package_name exists in the sim directory environment setup: it modifies the environment for the launch subprocess this is the key to making gazebo find all the necessary files it sets the following environment variables: gazebomodelpath: points to the models directory in your sim package gzsimresource_path: points to both the worlds and models directories gazebo_world: set to the value of the --world option headless: set to 1 if the --headless flag is used execution: it sources the local workspace and executes the main launch file for the simulation package ros2 launch packagename packagename launch py using the modified environment example:",
      "headings": [
        "`genesys sim create`",
        "`genesys sim run`"
      ],
      "keywords": [
        "`genesys sim create`",
        "`genesys sim run`",
        "`<package_name>`",
        "must",
        "`--from-pkg <robot_description_package>`",
        "Directory Creation",
        "Dependency Check",
        "Template Rendering",
        "URDF Linking",
        "symlink",
        "Example:",
        "`--world <world_file.world>`",
        "`--headless`",
        "Workspace Validation",
        "Environment Setup",
        "Execution",
        "genesys sim",
        "genesys sim create",
        "*_gazebo",
        "sim/",
        "bash\ngenesys sim create <package_name> --from-pkg <robot_description_package>",
        "* **",
        "**: The name of the simulation package. By convention, this **must** end in",
        "(e.g.,",
        ").\n* **",
        "**: The name of an existing package that contains the robot's URDF or XACRO files (e.g.,",
        ").\n\n### How It Works\n\nThis command automates the creation of a complete Gazebo simulation package.\n\n1. **Directory Creation**: It creates a new package inside the",
        "directory (creating",
        "if it doesn't exist). This keeps simulation packages separate from your robot's source code in",
        ".\n2. **Dependency Check**: It runs",
        "and",
        "to ensure that necessary simulation dependencies like",
        "are installed on your system.\n3. **Template Rendering**: It generates a standard set of subdirectories (",
        ",",
        ") and populates them with boilerplate files rendered from internal templates. This includes:\n   *",
        "* A main launch file (",
        ") to start Gazebo and the robot.\n   * A secondary launch file to spawn the robot model (",
        ").\n   * A default",
        "for a",
        "setup.\n   *",
        "files.\n4. **URDF Linking**: To ensure the simulation always uses the most up-to-date robot model, it tries to **symlink** the",
        "directory from the source package (",
        ") into the new simulation package. If symlinking fails (e.g., due to permissions), it falls back to copying the directory.\n\n**Example:**",
        "bash\ngenesys sim create my_robot_gazebo --from-pkg my_robot_description",
        "***\n\n##",
        "Launches a Gazebo simulation from one of the",
        "packages.\n\n### Usage",
        "bash\ngenesys sim run <package_name> [options]",
        "**: The name of the simulation package to run (e.g.,",
        "). It must be located in the",
        "directory.\n\n### Options\n\n* **",
        "**: Specify a world file to load from the package's",
        "directory. Defaults to",
        ".\n* **",
        "**: Run Gazebo in headless mode (no GUI). This is useful for running simulations on a server or as part of a CI/CD pipeline.\n\n### How It Works\n\n1. **Workspace Validation**: Checks that the workspace has been built (",
        "exists) and the specified",
        "exists in the",
        "directory.\n2. **Environment Setup**: It modifies the environment for the launch subprocess. This is the key to making Gazebo find all the necessary files. It sets the following environment variables:\n   *",
        ": Points to the",
        "directory in your sim package.\n   *",
        ": Points to both the",
        "directories.\n   *",
        ": Set to the value of the",
        "option.\n   *",
        ": Set to",
        "if the",
        "flag is used.\n3. **Execution**: It sources the local workspace and executes the main launch file for the simulation package (",
        ") using the modified environment.\n\n**Example:**",
        "bash\n# Run the simulation with a GUI and a specific world\r\ngenesys sim run my_robot_gazebo --world my_world.world\r\n\r\n# Run the simulation without a GUI\r\ngenesys sim run my_robot_gazebo --headless"
      ]
    }
  },
  {
    "slug": "/markdown/cards",
    "title": "Cards",
    "description": "Explore and implement various card styles, including small, large and image cards.",
    "content": "This section introduces the different card styles available in the system, from compact small cards to visually rich image cards. Each example is paired with JSX code snippets, providing you with a practical guide to incorporate these components seamlessly into your project.\n\n## Small Card\n\n```jsx\n<CardGrid>\r\n  <Card\r\n    title=\"Instructions\"\r\n    href=\"/docs/basic-setup/installation\"\r\n    icon=\"alignJustify\"\r\n    variant=\"small\"\r\n    description=\"test description\"\r\n  />\r\n  <Card\r\n    title=\"Setup\"\r\n    href=\"/docs/basic-setup/setup\"\r\n    icon=\"alignJustify\"\r\n    variant=\"small\"\r\n  />\r\n  <Card\r\n    title=\"Rubix Studios\"\r\n    href=\"https://rubixstudios.com.au\"\r\n    icon=\"alignJustify\"\r\n    external={true}\r\n    variant=\"small\"\r\n  />\r\n</CardGrid>\n```\n\n## Large Card\n\n```jsx\n<CardGrid>\r\n  <Card\r\n    subtitle=\"Instructions\"\r\n    title=\"Installation\"\r\n    description=\"Get started with Documents using our quick start installation guide to get your project started.\"\r\n    href=\"/docs/basic-setup/installation\"\r\n  />\r\n  <Card\r\n    subtitle=\"Setup\"\r\n    title=\"Site Settings\"\r\n    description=\"Setting up your Documents projects layout, links and search engine optimisation.\"\r\n    href=\"/docs/basic-setup/setup\"\r\n  />\r\n  <Card\r\n    subtitle=\"Support\"\r\n    title=\"Rubix Studios\"\r\n    description=\"Australia's leading branding, marketing and web development company.\"\r\n    href=\"https://rubixstudios.com.au\"\r\n    external={true}\r\n  />\r\n</CardGrid>\n```\n\n## Image Card\n\n```jsx\n<CardGrid>\r\n  <Card\r\n    title=\"Instructions\"\r\n    href=\"/docs/introduction/installation\"\r\n    image=\"/images/og-image.png\"\r\n    variant=\"image\"\r\n  />\r\n  <Card\r\n    title=\"Setup\"\r\n    href=\"/docs/introduction/setup\"\r\n    image=\"/images/og-image.png\"\r\n    variant=\"image\"\r\n  />\r\n  <Card\r\n    title=\"Rubix Studios\"\r\n    href=\"https://www.rubixstudios.com.au\"\r\n    image=\"/images/og-image.png\"\r\n    external={true}\r\n    variant=\"image\"\r\n  />\r\n</CardGrid>\n```\n",
    "_searchMeta": {
      "cleanContent": "this section introduces the different card styles available in the system from compact small cards to visually rich image cards each example is paired with jsx code snippets providing you with a practical guide to incorporate these components seamlessly into your project small card large card image card",
      "headings": [
        "Small Card",
        "Large Card",
        "Image Card"
      ],
      "keywords": [
        "Small Card",
        "Large Card",
        "Image Card",
        "jsx\n<CardGrid>\r\n  <Card\r\n    title=\"Instructions\"\r\n    href=\"/docs/basic-setup/installation\"\r\n    icon=\"alignJustify\"\r\n    variant=\"small\"\r\n    description=\"test description\"\r\n  />\r\n  <Card\r\n    title=\"Setup\"\r\n    href=\"/docs/basic-setup/setup\"\r\n    icon=\"alignJustify\"\r\n    variant=\"small\"\r\n  />\r\n  <Card\r\n    title=\"Rubix Studios\"\r\n    href=\"https://rubixstudios.com.au\"\r\n    icon=\"alignJustify\"\r\n    external={true}\r\n    variant=\"small\"\r\n  />\r\n</CardGrid>",
        "## Large Card",
        "jsx\n<CardGrid>\r\n  <Card\r\n    subtitle=\"Instructions\"\r\n    title=\"Installation\"\r\n    description=\"Get started with Documents using our quick start installation guide to get your project started.\"\r\n    href=\"/docs/basic-setup/installation\"\r\n  />\r\n  <Card\r\n    subtitle=\"Setup\"\r\n    title=\"Site Settings\"\r\n    description=\"Setting up your Documents projects layout, links and search engine optimisation.\"\r\n    href=\"/docs/basic-setup/setup\"\r\n  />\r\n  <Card\r\n    subtitle=\"Support\"\r\n    title=\"Rubix Studios\"\r\n    description=\"Australia's leading branding, marketing and web development company.\"\r\n    href=\"https://rubixstudios.com.au\"\r\n    external={true}\r\n  />\r\n</CardGrid>",
        "## Image Card",
        "jsx\n<CardGrid>\r\n  <Card\r\n    title=\"Instructions\"\r\n    href=\"/docs/introduction/installation\"\r\n    image=\"/images/og-image.png\"\r\n    variant=\"image\"\r\n  />\r\n  <Card\r\n    title=\"Setup\"\r\n    href=\"/docs/introduction/setup\"\r\n    image=\"/images/og-image.png\"\r\n    variant=\"image\"\r\n  />\r\n  <Card\r\n    title=\"Rubix Studios\"\r\n    href=\"https://www.rubixstudios.com.au\"\r\n    image=\"/images/og-image.png\"\r\n    external={true}\r\n    variant=\"image\"\r\n  />\r\n</CardGrid>"
      ]
    }
  },
  {
    "slug": "/markdown/diagrams",
    "title": "Diagrams",
    "description": "Add various diagram types, including flowcharts, decision trees and entity-relationship diagrams.",
    "content": "Diagrams are powerful tools for visualizing processes, relationships, and decisions. This section showcases different types of diagrams created using **Mermaid**, complete with examples and reusable code snippets to integrate into your projects.\n\n## Flowchart\n\nA flowchart represents a sequence of steps or processes in a visual format. Use this diagram to map workflows, decision-making processes, or operational flows.\n\n```jsx\n<Mermaid\r\n  chart={\\`\r\n    graph TD;\r\n    Start --> Task1;\r\n    Task1 --> Task2;\r\n    Task2 --> End;\r\n  \\`}\r\n/>\n```\n\n## Decision Tree\n\nDecision trees illustrate choices and possible outcomes, making them ideal for decision-making workflows or processes involving multiple paths.\n\n```jsx\n<Mermaid\r\n  chart={\\`\r\n    graph TD;\r\n    A[Start] --> B{Is it raining?};\r\n    B -->|Yes| C[Take an umbrella];\r\n    B -->|No| D[Enjoy the weather];\r\n    C --> E[Go outside];\r\n    D --> E;\r\n  \\`}\r\n/>\n```\n\n## Entity-Relationship Diagram\n\nEntity-relationship diagrams (ERDs) are used to model relationships between entities in a system. They are widely used in database design and system architecture planning.\n\n```jsx\n<Mermaid\r\n  chart={\\`\r\n    erDiagram\r\n    CUSTOMER ||--o{ ORDER : places\r\n    ORDER ||--|{ LINE-ITEM : contains\r\n    PRODUCT ||--o{ LINE-ITEM : \"included in\"\r\n    CUSTOMER {\r\n        string name\r\n        string email\r\n    }\r\n    ORDER {\r\n        int orderNumber\r\n        date orderDate\r\n    }\r\n    LINE-ITEM {\r\n        int quantity\r\n        float price\r\n    }\r\n    PRODUCT {\r\n        int productId\r\n        string name\r\n        float price\r\n    }\r\n  \\`}\r\n/>\n```\n\nEach of these diagrams serves a specific purpose and Mermaid makes it easy to generate them dynamically. Feel free to experiment with the provided code snippets and adapt them to your needs.\n",
    "_searchMeta": {
      "cleanContent": "diagrams are powerful tools for visualizing processes relationships and decisions this section showcases different types of diagrams created using mermaid complete with examples and reusable code snippets to integrate into your projects flowchart a flowchart represents a sequence of steps or processes in a visual format use this diagram to map workflows decision-making processes or operational flows decision tree decision trees illustrate choices and possible outcomes making them ideal for decision-making workflows or processes involving multiple paths entity-relationship diagram entity-relationship diagrams erds are used to model relationships between entities in a system they are widely used in database design and system architecture planning each of these diagrams serves a specific purpose and mermaid makes it easy to generate them dynamically feel free to experiment with the provided code snippets and adapt them to your needs",
      "headings": [
        "Flowchart",
        "Decision Tree",
        "Entity-Relationship Diagram"
      ],
      "keywords": [
        "Flowchart",
        "Decision Tree",
        "Entity-Relationship Diagram",
        "Mermaid",
        "jsx\n<Mermaid\r\n  chart={\\",
        "}\r\n/>",
        "## Decision Tree\n\nDecision trees illustrate choices and possible outcomes, making them ideal for decision-making workflows or processes involving multiple paths.",
        "## Entity-Relationship Diagram\n\nEntity-relationship diagrams (ERDs) are used to model relationships between entities in a system. They are widely used in database design and system architecture planning."
      ]
    }
  },
  {
    "slug": "/markdown/filetree",
    "title": "Filetree",
    "description": "This section provides an overview of file structures and their implementation using the FileTree component.",
    "content": "This section demonstrates the structure of a file tree using the `FileTree` component. Below is an example showcasing folders and files organized hierarchically for a project setup.\n\n## How to Use\n\nIntegrate the `FileTree` component into your project to visually represent file and folder structures. This is particularly useful for documentation, tutorials, or providing users with an overview of your project's architecture.\n\n### JSX Code Example\n\nHere is how you can define the file tree structure in for use in your project:\n\n```jsx\n<FileTree>\r\n  <Folder name=\"src\" label=\"Source Code\">\r\n    <File name=\"index.tsx\" label=\"Index File\" />\r\n    <Folder name=\"components\" label=\"Components\">\r\n      <File name=\"button.tsx\" label=\"Button Component\" />\r\n      <File name=\"input.tsx\" label=\"Input Component\" />\r\n    </Folder>\r\n    <Folder name=\"pages\" label=\"Pages\">\r\n      <File name=\"home.tsx\" label=\"Home Page\" />\r\n      <File name=\"about.tsx\" label=\"About Page\" />\r\n    </Folder>\r\n  </Folder>\r\n</FileTree>\n```\n\nUse this code as a template to set up your own file tree structure and customize it as needed.\n",
    "_searchMeta": {
      "cleanContent": "this section demonstrates the structure of a file tree using the filetree component below is an example showcasing folders and files organized hierarchically for a project setup how to use integrate the filetree component into your project to visually represent file and folder structures this is particularly useful for documentation tutorials or providing users with an overview of your project s architecture jsx code example here is how you can define the file tree structure in for use in your project: use this code as a template to set up your own file tree structure and customize it as needed",
      "headings": [
        "How to Use"
      ],
      "keywords": [
        "How to Use",
        "FileTree",
        "jsx\n<FileTree>\r\n  <Folder name=\"src\" label=\"Source Code\">\r\n    <File name=\"index.tsx\" label=\"Index File\" />\r\n    <Folder name=\"components\" label=\"Components\">\r\n      <File name=\"button.tsx\" label=\"Button Component\" />\r\n      <File name=\"input.tsx\" label=\"Input Component\" />\r\n    </Folder>\r\n    <Folder name=\"pages\" label=\"Pages\">\r\n      <File name=\"home.tsx\" label=\"Home Page\" />\r\n      <File name=\"about.tsx\" label=\"About Page\" />\r\n    </Folder>\r\n  </Folder>\r\n</FileTree>"
      ]
    }
  },
  {
    "slug": "/markdown",
    "title": "Introduction",
    "description": "This section provides an overview of Introduction.",
    "content": "Lorem ipsum dolor sit amet consectetur adipisicing elit. Numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime, molestiae, facilis aperiam et, error illum vel ullam? Quis architecto dolore ullam\n\n* \\[x] Write the press release\n* \\[ ] Update the website\n* \\[ ] Contact the media\n\n| Syntax        | Description |   Test Text |\r\n| :------------ | :---------: | ----------: |\r\n| Header        |    Title    | Here's this |\r\n| Paragraph     |    Text     |    And more |\r\n| Strikethrough |             |    ~~Text~~ |\n\n## Sample Document with Mermaid\n\nHere is a Mermaid diagram:\n\nThis diagram should render automatically without any extra imports.\n\n## Getting Started\n\nTo begin using the Documentation Template, follow these simple steps:\n\n* Start by cloning the repository to your local machine.\n\nLorem ipsum dolor sit amet consectetur adipisicing elit. Reprehenderit quae iure nulla deserunt dolore quam pariatur minus sapiente accusantium. Optio, necessitatibus sequi. Veritatis, aspernatur? Possimus quis repellat eum vitae eveniet.\n\n## Blockquotes\n\nBlockquotes are useful for emphasizing key points or quoting external sources:\n\n> \"Documentation is a love letter that you write to your future self.\" - Damian Conway\n\nFeel free to use blockquotes to highlight important information or quotes relevant to your documentation.\n\n## Code Examples with switch\n\nHere a custom tab component from shadcn ui is used.\n\n## Conclusion\n\nThank you for choosing the Documentation Template for your project. Whether you're documenting software, APIs, or processes, we're here to support you in creating clear and effective documentation. Happy documenting!\n",
    "_searchMeta": {
      "cleanContent": "lorem ipsum dolor sit amet consectetur adipisicing elit numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime molestiae facilis aperiam et error illum vel ullam quis architecto dolore ullam x write the press release update the website contact the media syntax description test text :------------ :---------: ----------: header title here s this paragraph text and more strikethrough text sample document with mermaid here is a mermaid diagram: this diagram should render automatically without any extra imports getting started to begin using the documentation template follow these simple steps: start by cloning the repository to your local machine lorem ipsum dolor sit amet consectetur adipisicing elit reprehenderit quae iure nulla deserunt dolore quam pariatur minus sapiente accusantium optio necessitatibus sequi veritatis aspernatur possimus quis repellat eum vitae eveniet blockquotes blockquotes are useful for emphasizing key points or quoting external sources: documentation is a love letter that you write to your future self - damian conway feel free to use blockquotes to highlight important information or quotes relevant to your documentation code examples with switch here a custom tab component from shadcn ui is used conclusion thank you for choosing the documentation template for your project whether you re documenting software apis or processes we re here to support you in creating clear and effective documentation happy documenting",
      "headings": [
        "Sample Document with Mermaid",
        "Getting Started",
        "Blockquotes",
        "Code Examples with switch",
        "Conclusion"
      ],
      "keywords": [
        "Sample Document with Mermaid",
        "Getting Started",
        "Blockquotes",
        "Code Examples with switch",
        "Conclusion"
      ]
    }
  },
  {
    "slug": "/markdown/lists",
    "title": "Lists",
    "description": "This section provides an overview of creating and using lists in the Documents boilerplate.",
    "content": "Learn how to create and render different types of lists in the Documents boilerplate. Examples include checklists, ordered lists, unordered lists and nested lists.\n\n## Checklist\n\n* \\[x] Write the press release\n* \\[ ] Update the website\n* \\[ ] Contact the media\n\n```jsx\n- [x] Write the press release\r\n- [ ] Update the website\r\n- [ ] Contact the media\n```\n\n## Simple List\n\n* Item 1\n* Item 2\n* Item 3\n\n```jsx\n- Item 1\r\n- Item 2\r\n- Item 3\n```\n\n## Number List\n\n1. Research\n2. Draft the content\n3. Review and edit\n4. Publish\n\n```jsx\n1. Research\r\n2. Draft the content\r\n3. Review and edit\r\n4. Publish\n```\n\n## Nested List\n\n* Main Category 1\n  * Sub Item 1.1\n  * Sub Item 1.2\n* Main Category 2\n  * Sub Item 2.1\n  * Sub Item 2.2\n\n```jsx\n- Main Category 1\r\n  - Sub Item 1.1\r\n  - Sub Item 1.2\r\n- Main Category 2\r\n  - Sub Item 2.1\r\n  - Sub Item 2.2\n```\n\nUse these examples as a foundation to create and customize lists that fit your project's needs.\n",
    "_searchMeta": {
      "cleanContent": "learn how to create and render different types of lists in the documents boilerplate examples include checklists ordered lists unordered lists and nested lists checklist x write the press release update the website contact the media simple list item 1 item 2 item 3 number list research draft the content review and edit publish nested list main category 1 sub item 1 1 sub item 1 2 main category 2 sub item 2 1 sub item 2 2 use these examples as a foundation to create and customize lists that fit your project s needs",
      "headings": [
        "Checklist",
        "Simple List",
        "Number List",
        "Nested List"
      ],
      "keywords": [
        "Checklist",
        "Simple List",
        "Number List",
        "Nested List",
        "jsx\n- [x] Write the press release\r\n- [ ] Update the website\r\n- [ ] Contact the media",
        "## Simple List\n\n* Item 1\n* Item 2\n* Item 3",
        "jsx\n- Item 1\r\n- Item 2\r\n- Item 3",
        "## Number List\n\n1. Research\n2. Draft the content\n3. Review and edit\n4. Publish",
        "jsx\n1. Research\r\n2. Draft the content\r\n3. Review and edit\r\n4. Publish",
        "## Nested List\n\n* Main Category 1\n  * Sub Item 1.1\n  * Sub Item 1.2\n* Main Category 2\n  * Sub Item 2.1\n  * Sub Item 2.2",
        "jsx\n- Main Category 1\r\n  - Sub Item 1.1\r\n  - Sub Item 1.2\r\n- Main Category 2\r\n  - Sub Item 2.1\r\n  - Sub Item 2.2"
      ]
    }
  },
  {
    "slug": "/markdown/maths",
    "title": "Maths",
    "description": "This section provides an overview of Introduction.",
    "content": "Lorem ipsum dolor sit amet consectetur adipisicing elit. Numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime, molestiae, facilis aperiam et, error illum vel ullam? Quis architecto dolore ullam\n\n## Basic Algebra\n\nThe area of a circle ($$A$$) can be calculated using the radius ($$r$$) as follows:\n\n```math\nA = \\pi r^2\n```\n\n## Quadratic Formula\n\nThe quadratic formula for solving an equation of the form $$ax^2 + bx + c = 0$$ is:\n\n```math\nx = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}\n```\n\n## Newton's Second Law of Motion\n\nNewton's second law of motion states that force ($$F$$) is the product of mass ($$m$$) and acceleration ($$a$$):\n\n```math\nF = ma\n```\n\n## Pythagorean Theorem\n\nThe Pythagorean theorem relates the lengths of the sides of a right triangle:\n\n```math\na^2 + b^2 = c^2\n```\n\n## Einstein's Mass-Energy Equivalence\n\nEinstein's famous equation relates energy ($$E$$), mass ($$m$$), and the speed of light ($$c$$):\n\n```math\nE = mc^2\n```\n",
    "_searchMeta": {
      "cleanContent": "lorem ipsum dolor sit amet consectetur adipisicing elit numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime molestiae facilis aperiam et error illum vel ullam quis architecto dolore ullam basic algebra the area of a circle a can be calculated using the radius r as follows: quadratic formula the quadratic formula for solving an equation of the form ax 2 bx c 0 is: newton s second law of motion newton s second law of motion states that force f is the product of mass m and acceleration a : pythagorean theorem the pythagorean theorem relates the lengths of the sides of a right triangle: einstein s mass-energy equivalence einstein s famous equation relates energy e mass m and the speed of light c :",
      "headings": [
        "Basic Algebra",
        "Quadratic Formula",
        "Newton's Second Law of Motion",
        "Pythagorean Theorem",
        "Einstein's Mass-Energy Equivalence"
      ],
      "keywords": [
        "Basic Algebra",
        "Quadratic Formula",
        "Newton's Second Law of Motion",
        "Pythagorean Theorem",
        "Einstein's Mass-Energy Equivalence",
        "math\nA = \\pi r^2",
        "## Quadratic Formula\n\nThe quadratic formula for solving an equation of the form $$ax^2 + bx + c = 0$$ is:",
        "math\nx = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}",
        "## Newton's Second Law of Motion\n\nNewton's second law of motion states that force ($$F$$) is the product of mass ($$m$$) and acceleration ($$a$$):",
        "math\nF = ma",
        "## Pythagorean Theorem\n\nThe Pythagorean theorem relates the lengths of the sides of a right triangle:",
        "math\na^2 + b^2 = c^2",
        "## Einstein's Mass-Energy Equivalence\n\nEinstein's famous equation relates energy ($$E$$), mass ($$m$$), and the speed of light ($$c$$):",
        "math\nE = mc^2"
      ]
    }
  },
  {
    "slug": "/markdown/notes",
    "title": "Notes",
    "description": "This section provides an overview of Introduction.",
    "content": "Lorem ipsum dolor sit amet consectetur adipisicing elit. Numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime, molestiae, facilis aperiam et, error illum vel ullam? Quis architecto dolore ullam\n\n## Standard Note\n\n## Success Note\n\n## Warning Note\n\n## Danger Note\n",
    "_searchMeta": {
      "cleanContent": "lorem ipsum dolor sit amet consectetur adipisicing elit numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime molestiae facilis aperiam et error illum vel ullam quis architecto dolore ullam standard note success note warning note danger note",
      "headings": [
        "Standard Note",
        "Success Note",
        "Warning Note",
        "Danger Note"
      ],
      "keywords": [
        "Standard Note",
        "Success Note",
        "Warning Note",
        "Danger Note"
      ]
    }
  },
  {
    "slug": "/markdown/steps",
    "title": "Steps",
    "description": "This section provides an overview of Introduction.",
    "content": "The `<Step>` and `<StepItem>` components allow you to create structured step-by-step guides in your documentation. These components are particularly useful when you want to break down a process or tutorial into easy-to-follow stages.\n\n## Steps\n\nTo create a step-by-step guide in your MDX, you can use the following structure:\n",
    "_searchMeta": {
      "cleanContent": "the step and stepitem components allow you to create structured step-by-step guides in your documentation these components are particularly useful when you want to break down a process or tutorial into easy-to-follow stages steps to create a step-by-step guide in your mdx you can use the following structure:",
      "headings": [
        "Steps"
      ],
      "keywords": [
        "Steps",
        "<Step>",
        "<StepItem>"
      ]
    }
  },
  {
    "slug": "/markdown/table",
    "title": "Table",
    "description": "This section provides an overview of Introduction.",
    "content": "Lorem ipsum dolor sit amet consectetur adipisicing elit. Numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime, molestiae, facilis aperiam et, error illum vel ullam? Quis architecto dolore ullam\n\n| Syntax        | Description |   Test Text |\r\n| :------------ | :---------: | ----------: |\r\n| Header        |    Title    | Here's this |\r\n| Paragraph     |    Text     |    And more |\r\n| Strikethrough |             |    ~~Text~~ |\n\n| Feature       | Documentation Link |                    Notes |\r\n| :------------ | :----------------: | -----------------------: |\r\n| **Feature A** |     [Docs](#)      | For more info click here |\r\n| **Feature B** |     [Guide](#)     |  See the full guide here |\r\n| **Feature C** |     [Setup](#)     |       Setup instructions |\n",
    "_searchMeta": {
      "cleanContent": "lorem ipsum dolor sit amet consectetur adipisicing elit numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime molestiae facilis aperiam et error illum vel ullam quis architecto dolore ullam syntax description test text :------------ :---------: ----------: header title here s this paragraph text and more strikethrough text feature documentation link notes :------------ :----------------: -----------------------: feature a docs for more info click here feature b guide see the full guide here feature c setup setup instructions",
      "headings": [],
      "keywords": [
        "Feature A",
        "Feature B",
        "Feature C"
      ]
    }
  },
  {
    "slug": "/markdown/tabs",
    "title": "Tabs",
    "description": "This section provides an overview of Introduction.",
    "content": "Lorem ipsum dolor sit amet consectetur adipisicing elit. Numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime, molestiae, facilis aperiam et, error illum vel ullam? Quis architecto dolore ullam\n\n## Code Examples with switch\n\nHere a custom tab component from shadcn ui is used.\n",
    "_searchMeta": {
      "cleanContent": "lorem ipsum dolor sit amet consectetur adipisicing elit numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime molestiae facilis aperiam et error illum vel ullam quis architecto dolore ullam code examples with switch here a custom tab component from shadcn ui is used",
      "headings": [
        "Code Examples with switch"
      ],
      "keywords": [
        "Code Examples with switch"
      ]
    }
  },
  {
    "slug": "/navigation",
    "title": "Navigation",
    "description": "How to build our your documents menu and navigations.",
    "content": "",
    "_searchMeta": {
      "cleanContent": "",
      "headings": [],
      "keywords": [
        "navigation",
        "sidebar",
        "menus",
        "mdx",
        "nextjs",
        "documents"
      ]
    }
  },
  {
    "slug": "/random",
    "title": "Introduction",
    "description": "This section provides an overview of Introduction.",
    "content": "Lorem ipsum dolor sit amet consectetur adipisicing elit. Numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime, molestiae, facilis aperiam et, error illum vel ullam? Quis architecto dolore ullam\n\n* \\[x] Write the press release\n* \\[ ] Update the website\n* \\[ ] Contact the media\n\n| Syntax        | Description |   Test Text |\r\n| :------------ | :---------: | ----------: |\r\n| Header        |    Title    | Here's this |\r\n| Paragraph     |    Text     |    And more |\r\n| Strikethrough |             |    ~~Text~~ |\n\n## Getting Started\n\nTo begin using the Documentation Template, follow these simple steps:\n\n* Start by cloning the repository to your local machine.\n\nLorem ipsum dolor sit amet consectetur adipisicing elit. Reprehenderit quae iure nulla deserunt dolore quam pariatur minus sapiente accusantium. Optio, necessitatibus sequi. Veritatis, aspernatur? Possimus quis repellat eum vitae eveniet.\n\n## Blockquotes\n\nBlockquotes are useful for emphasizing key points or quoting external sources:\n\n> \"Documentation is a love letter that you write to your future self.\" - Damian Conway\n\nFeel free to use blockquotes to highlight important information or quotes relevant to your documentation.\n\n## Code Examples with switch\n\nHere a custom tab component from shadcn ui is used.\n\n## Conclusion\n\nAdding some random stuff to change the code\n",
    "_searchMeta": {
      "cleanContent": "lorem ipsum dolor sit amet consectetur adipisicing elit numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime molestiae facilis aperiam et error illum vel ullam quis architecto dolore ullam x write the press release update the website contact the media syntax description test text :------------ :---------: ----------: header title here s this paragraph text and more strikethrough text getting started to begin using the documentation template follow these simple steps: start by cloning the repository to your local machine lorem ipsum dolor sit amet consectetur adipisicing elit reprehenderit quae iure nulla deserunt dolore quam pariatur minus sapiente accusantium optio necessitatibus sequi veritatis aspernatur possimus quis repellat eum vitae eveniet blockquotes blockquotes are useful for emphasizing key points or quoting external sources: documentation is a love letter that you write to your future self - damian conway feel free to use blockquotes to highlight important information or quotes relevant to your documentation code examples with switch here a custom tab component from shadcn ui is used conclusion adding some random stuff to change the code",
      "headings": [
        "Getting Started",
        "Blockquotes",
        "Code Examples with switch",
        "Conclusion"
      ],
      "keywords": [
        "Getting Started",
        "Blockquotes",
        "Code Examples with switch",
        "Conclusion"
      ]
    }
  },
  {
    "slug": "/structure/deep/deeper/even-deeper",
    "title": "Introduction",
    "description": "This section provides an overview of Introduction.",
    "content": "Lorem ipsum dolor sit amet consectetur adipisicing elit. Numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime, molestiae, facilis aperiam et, error illum vel ullam? Quis architecto dolore ullam\n\n* \\[x] Write the press release\n* \\[ ] Update the website\n* \\[ ] Contact the media\n\n| Syntax        | Description |   Test Text |\r\n| :------------ | :---------: | ----------: |\r\n| Header        |    Title    | Here's this |\r\n| Paragraph     |    Text     |    And more |\r\n| Strikethrough |             |    ~~Text~~ |\n",
    "_searchMeta": {
      "cleanContent": "lorem ipsum dolor sit amet consectetur adipisicing elit numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime molestiae facilis aperiam et error illum vel ullam quis architecto dolore ullam x write the press release update the website contact the media syntax description test text :------------ :---------: ----------: header title here s this paragraph text and more strikethrough text",
      "headings": [],
      "keywords": []
    }
  },
  {
    "slug": "/structure/deep/deeper",
    "title": "Introduction",
    "description": "This section provides an overview of Introduction.",
    "content": "Lorem ipsum dolor sit amet consectetur adipisicing elit. Numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime, molestiae, facilis aperiam et, error illum vel ullam? Quis architecto dolore ullam\n\n* \\[x] Write the press release\n* \\[ ] Update the website\n* \\[ ] Contact the media\n\n| Syntax        | Description |   Test Text |\r\n| :------------ | :---------: | ----------: |\r\n| Header        |    Title    | Here's this |\r\n| Paragraph     |    Text     |    And more |\r\n| Strikethrough |             |    ~~Text~~ |\n\n## Getting Started\n\nTo begin using the Documentation Template, follow these simple steps:\n\n* Start by cloning the repository to your local machine.\n\nLorem ipsum dolor sit amet consectetur adipisicing elit. Reprehenderit quae iure nulla deserunt dolore quam pariatur minus sapiente accusantium. Optio, necessitatibus sequi. Veritatis, aspernatur? Possimus quis repellat eum vitae eveniet.\n\n## Blockquotes\n\nBlockquotes are useful for emphasizing key points or quoting external sources:\n\n> \"Documentation is a love letter that you write to your future self.\" - Damian Conway\n\nFeel free to use blockquotes to highlight important information or quotes relevant to your documentation.\n\n## Code Examples with switch\n\nHere a custom tab component from shadcn ui is used.\n\n## Conclusion\n\nThank you for choosing the Documentation Template for your project. Whether you're documenting software, APIs, or processes, we're here to support you in creating clear and effective documentation. Happy documenting!\n\n## Tabs Example\n",
    "_searchMeta": {
      "cleanContent": "lorem ipsum dolor sit amet consectetur adipisicing elit numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime molestiae facilis aperiam et error illum vel ullam quis architecto dolore ullam x write the press release update the website contact the media syntax description test text :------------ :---------: ----------: header title here s this paragraph text and more strikethrough text getting started to begin using the documentation template follow these simple steps: start by cloning the repository to your local machine lorem ipsum dolor sit amet consectetur adipisicing elit reprehenderit quae iure nulla deserunt dolore quam pariatur minus sapiente accusantium optio necessitatibus sequi veritatis aspernatur possimus quis repellat eum vitae eveniet blockquotes blockquotes are useful for emphasizing key points or quoting external sources: documentation is a love letter that you write to your future self - damian conway feel free to use blockquotes to highlight important information or quotes relevant to your documentation code examples with switch here a custom tab component from shadcn ui is used conclusion thank you for choosing the documentation template for your project whether you re documenting software apis or processes we re here to support you in creating clear and effective documentation happy documenting tabs example",
      "headings": [
        "Getting Started",
        "Blockquotes",
        "Code Examples with switch",
        "Conclusion",
        "Tabs Example"
      ],
      "keywords": [
        "Getting Started",
        "Blockquotes",
        "Code Examples with switch",
        "Conclusion",
        "Tabs Example"
      ]
    }
  },
  {
    "slug": "/structure/deep",
    "title": "Introduction",
    "description": "This section provides an overview of Introduction.",
    "content": "Lorem ipsum dolor sit amet consectetur adipisicing elit. Numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime, molestiae, facilis aperiam et, error illum vel ullam? Quis architecto dolore ullam\n\n* \\[x] Write the press release\n* \\[ ] Update the website\n* \\[ ] Contact the media\n\n| Syntax        | Description |   Test Text |\r\n| :------------ | :---------: | ----------: |\r\n| Header        |    Title    | Here's this |\r\n| Paragraph     |    Text     |    And more |\r\n| Strikethrough |             |    ~~Text~~ |\n\n## Getting Started\n\nTo begin using the Documentation Template, follow these simple steps:\n\n* Start by cloning the repository to your local machine.\n\nLorem ipsum dolor sit amet consectetur adipisicing elit. Reprehenderit quae iure nulla deserunt dolore quam pariatur minus sapiente accusantium. Optio, necessitatibus sequi. Veritatis, aspernatur? Possimus quis repellat eum vitae eveniet.\n\n## Blockquotes\n\nBlockquotes are useful for emphasizing key points or quoting external sources:\n\n> \"Documentation is a love letter that you write to your future self.\" - Damian Conway\n\nFeel free to use blockquotes to highlight important information or quotes relevant to your documentation.\n\n## Code Examples with switch\n\nHere a custom tab component from shadcn ui is used.\n\n## Conclusion\n\nThank you for choosing the Documentation Template for your project. Whether you're documenting software, APIs, or processes, we're here to support you in creating clear and effective documentation. Happy documenting!\n\n## Tabs Example\n",
    "_searchMeta": {
      "cleanContent": "lorem ipsum dolor sit amet consectetur adipisicing elit numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime molestiae facilis aperiam et error illum vel ullam quis architecto dolore ullam x write the press release update the website contact the media syntax description test text :------------ :---------: ----------: header title here s this paragraph text and more strikethrough text getting started to begin using the documentation template follow these simple steps: start by cloning the repository to your local machine lorem ipsum dolor sit amet consectetur adipisicing elit reprehenderit quae iure nulla deserunt dolore quam pariatur minus sapiente accusantium optio necessitatibus sequi veritatis aspernatur possimus quis repellat eum vitae eveniet blockquotes blockquotes are useful for emphasizing key points or quoting external sources: documentation is a love letter that you write to your future self - damian conway feel free to use blockquotes to highlight important information or quotes relevant to your documentation code examples with switch here a custom tab component from shadcn ui is used conclusion thank you for choosing the documentation template for your project whether you re documenting software apis or processes we re here to support you in creating clear and effective documentation happy documenting tabs example",
      "headings": [
        "Getting Started",
        "Blockquotes",
        "Code Examples with switch",
        "Conclusion",
        "Tabs Example"
      ],
      "keywords": [
        "Getting Started",
        "Blockquotes",
        "Code Examples with switch",
        "Conclusion",
        "Tabs Example"
      ]
    }
  },
  {
    "slug": "/structure",
    "title": "Structure",
    "description": "This section provides an overview of Introduction.",
    "content": "Lorem ipsum dolor sit amet consectetur adipisicing elit. Numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime, molestiae, facilis aperiam et, error illum vel ullam? Quis architecto dolore ullam\n\n* \\[x] Write the press release\n* \\[ ] Update the website\n* \\[ ] Contact the media\n\n| Syntax        | Description |   Test Text |\r\n| :------------ | :---------: | ----------: |\r\n| Header        |    Title    | Here's this |\r\n| Paragraph     |    Text     |    And more |\r\n| Strikethrough |             |    ~~Text~~ |\n\n## Getting Started\n\nTo begin using the Documentation Template, follow these simple steps:\n\n* Start by cloning the repository to your local machine.\n\nLorem ipsum dolor sit amet consectetur adipisicing elit. Reprehenderit quae iure nulla deserunt dolore quam pariatur minus sapiente accusantium. Optio, necessitatibus sequi. Veritatis, aspernatur? Possimus quis repellat eum vitae eveniet.\n\n## Blockquotes\n\nBlockquotes are useful for emphasizing key points or quoting external sources:\n\n> \"Documentation is a love letter that you write to your future self.\" - Damian Conway\n\nFeel free to use blockquotes to highlight important information or quotes relevant to your documentation.\n\n## Code Examples with switch\n\nHere a custom tab component from shadcn ui is used.\n\n## Conclusion\n\nThank you for choosing the Documentation Template for your project. Whether you're documenting software, APIs, or processes, we're here to support you in creating clear and effective documentation. Happy documenting!\n",
    "_searchMeta": {
      "cleanContent": "lorem ipsum dolor sit amet consectetur adipisicing elit numquam iste dolorum tempore consectetur explicabo tempora provident quia maxime molestiae facilis aperiam et error illum vel ullam quis architecto dolore ullam x write the press release update the website contact the media syntax description test text :------------ :---------: ----------: header title here s this paragraph text and more strikethrough text getting started to begin using the documentation template follow these simple steps: start by cloning the repository to your local machine lorem ipsum dolor sit amet consectetur adipisicing elit reprehenderit quae iure nulla deserunt dolore quam pariatur minus sapiente accusantium optio necessitatibus sequi veritatis aspernatur possimus quis repellat eum vitae eveniet blockquotes blockquotes are useful for emphasizing key points or quoting external sources: documentation is a love letter that you write to your future self - damian conway feel free to use blockquotes to highlight important information or quotes relevant to your documentation code examples with switch here a custom tab component from shadcn ui is used conclusion thank you for choosing the documentation template for your project whether you re documenting software apis or processes we re here to support you in creating clear and effective documentation happy documenting",
      "headings": [
        "Getting Started",
        "Blockquotes",
        "Code Examples with switch",
        "Conclusion"
      ],
      "keywords": [
        "Getting Started",
        "Blockquotes",
        "Code Examples with switch",
        "Conclusion"
      ]
    }
  }
]